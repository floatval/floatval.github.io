---
title: 希尔排序
date: 2020-04-15 22:14:01
author: 佚
copyright: true
categories:
- 数据结构与算法
- 排序
tags:
- 希尔排序
---
# 希尔排序
为了解决在数组中的数据量较大时,插入排序的效率过低的问题. `Donald Shell` 在1985年提出了 `希尔排序`.

希尔排序是一种 **缩小增量** 排序的方法.

1. 将无序的数组以固定的间隔 h 分割为不同的小数组
2. 将各个分割的数组进行排序
3. 现在大的数组已经分割为了 **较小的数组** 且 **小数组内有序**
4. 达到了 `插入排序` 的理想状态: 数组较小,且部分有序.

<!--more-->

# API 设计
和前几个排序算法一样,同样的 API 封装为通用的排序算法.

* 元素比较
* 元素交换
* 排序
* 遍历输入数组
* 判断数组是否有序

myshell.hpp
```C++
//
// Created by yi on 2020/4/15.
//

#ifndef PART2_MYSHELL_HPP
#define PART2_MYSHELL_HPP

#include <iostream>

template<typename T>
class myshell {
public:
    static void sort(T arr[], const size_t &&size);

    static bool isSorted(T arr[]);

    static bool less(const T &v, const T &w);

    static void exch(T arr[], const int &i, const int &j);

    static void show(T arr[], const size_t &&size);
};
```

# 实现
```C++
/**
 * 进行希尔排序
 * @tparam T 进行排序的数组中元素的类型
 * @param arr 进行排序的数组的首地址
 * @param size 进行排序的数组的元素个数
 */
template<typename T>
void myshell<T>::sort(T *arr, const size_t &&size) {
    int h = 1;
    /*求出进行希尔排序的最佳 h 的大小*/
    while (h < size / 3) {
        h = 3 * h + 1;
    }

    while (h >= 1) {
        for (int i = h; i < size; ++i) {
            for (int j = i; j >= h && less(*(arr + j), *(arr + (j - h))); j -= h) {
                exch(arr, j, j - h);
            }
        }
        h /= 3;
    }
}

/**
 * 判断数组是否有序,PS: 忽略了不定数量相等元素的情况
 * @tparam T 判断是否有序的数组中的元素的类型
 * @param arr 判断是否有序的数组的首地址
 * @return true：有序，false：无序
 */
template<typename T>
bool myshell<T>::isSorted(T *arr) {
    auto *temp = arr;
    return (*arr < *(temp++));
}

/**
 * 判断给定的两个元素的大小
 * @tparam T 元素的类型
 * @param v 待比较的元素
 * @param w 待比较的元素
 * @return true：v 小于 w，false： v 大于 w
 */
template<typename T>
bool myshell<T>::less(const T &v, const T &w) {
    return v < w;
}

/**
 * 交换给定的两个元素
 * @tparam T 数组中元素的类型
 * @param arr 数组的首地址
 * @param i 用于交换的元素的索引
 * @param j 用于交换的元素的索引
 */
template<typename T>
void myshell<T>::exch(T *arr, const int &i, const int &j) {
    *(arr + i) ^= *(arr + j);
    *(arr + j) ^= *(arr + i);
    *(arr + i) ^= *(arr + j);
}

/**
 * 遍历并打印给定的数组
 * @tparam T 用来遍历的数组中的元素的类型
 * @param arr 数组的首地址
 * @param size 数组中元素的数量
 */
template<typename T>
void myshell<T>::show(T *arr, const size_t &&size) {
    for (int i = 0; i < size; ++i) {
        std::cout << *(arr + i);
        std::cout << " ";
    }
    std::cout << std::endl;
}

#endif //PART2_MYSHELL_HPP
```

## 思路
{% note warning %}
一定要记住一点: 希尔排序是 **缩小增量排序**
{% endnote %}

1. 根据希尔排序的数学模型来选择适用于大多数情况的最优分割区间: h
2. 依照分割 h 来进行排序
3. 迭代最小分割 h 到出口条件 `h = 0`
