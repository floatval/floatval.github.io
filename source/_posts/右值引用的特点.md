---
title: 右值引用的特点
date: 2019-10-22 19:07:29
categories:
 - C++
tags:
 - 语义
 - 右值引用
copyright: true
author: 佚
---
# 右值引用的特点
***
右值引用的特点分为三部分：
 - 右值引用作用于临时变量
 - 右值引用的值类别
 - 右值引用的值类别的确定
 
右值引用是移动语义和完美转发的基础，是一个非常重要但又晦涩难懂的概念。若是从其特点对其进行归纳，则可以较好的对其进行理解。
 
 <!--more-->

# 右值引用作用于临时变量
***
```C++
#include <iostream>
using namespace std;

struct A
{
	A(){
        static int struct_count=0; // 构造函数调用次数计数
		cout<<"构造函数调用次数: "<<++struct_count<<endl; 
	}

	A(const A& a)
	{
        static int copy_count=0;  // 拷贝构造函数调用次数计数
		cout<<"拷贝构造函数调用次数: "<<++copy_count <<endl;
	}
	~A()
	{
		static int destruct_count=0; // 析构函数调用次数计数
        cout<<"析构函数调用次数: "<<++destruct_count<<endl;
	}
};

A getA()
{
	return A(); // C++ 为值语义，此处调用函数调用顺序为，一次构造函数，一次拷贝构造函数，一次析构
}

int main() {
	A a = getA(); // 此处调用一次拷贝构造，一次析构
	return 0;// 执行结束后 a 执行一次析构
}
```

## 不进行返回值优化时程序的运行结果

在利用 g++ 进行编译时，指定取消返回值优化  `-fno-elide-constructors` 后，我们可以获取到如下的输入:

>g++ 版本 7.4.0
>
>Linux 内核版本 4.15.0

>构造函数调用次数: 1 
>
>- 25 行 
>- 调用 **构造函数** 构造出一个临时对象 A （纯右值）
>
>拷贝构造函数调用次数: 1
>
>- 25 行
>
>- 调用 **拷贝构造**，将临时对象 A 进行值拷贝（匿名对象，纯右值）然后返回
>
>析构函数调用次数: 1
>
>- 25 行 
>- 调用 **析构函数**，将临时对象 A 进行析构
>
>拷贝构造函数调用次数: 2
>
>- 29 行
>- 将 getA 返回的匿名对象，拷贝赋值给 变量 a（纯右值赋值给左值）
>
>析构函数调用次数: 2
>
>- 29 行
>- 匿名对象在拷贝给变量 a 之后，改行代码执行完成，进行 **匿名对象** 的析构
>
>析构函数调用次数: 3
>
>- 30 行
>- 在 30 行执行完毕后，整个程序的生命周期结束，对变量进行释放，调用一次 **变量 a** 的析构函数

## 进行返回值优化后，程序的运行结果

进行返回值优化后，代码的输出如下:

>构造函数调用次数: 1
>析构函数调用次数: 1

可以很清楚的看到，编译器会将临时变量给进行优化（去除），但是在 C++ 的标准中未规定，要对临时变量进行优化。**这是编译器自身的行为，是不可预测的！**

## 右值引用时，程序的运行结果

那么有没有一种方法，可以让我们手动的实现类似编译器的优化效果，来达到代码在不同编译器编译后，行为的一致性呢？

答案是肯定的，我们可以通过 **右值引用** 来避免对 **临时对象频繁拷贝** 造成的开销。

对上述代码的 29 行进行优化：

>优化前：A a = getA(); 
>
>优化后：A&& a = getA();

编译时，同样的指定 **返回值优化** ，代码的执行结果如下：

> 构造函数调用次数: 1
>
> - 25 行
> - 调用 **构造函数** 构造出一个临时对象 A （纯右值）
>
> 拷贝构造函数调用次数: 1
>
> - 29 行
> - 调用 **拷贝构造函数** 将构造出的临时对象 A ，拷贝给一个 **匿名对象** ，进行返回
>
> 析构函数调用次数: 1
>
> - 29 行
> - 临时对象 A 在完成了，拷贝之后，调用析构函数
>
> 析构函数调用次数: 2
>
> - 30行
> - 在 30 行代码执行完毕之后，程序的生命周期结束，变量进行释放，此时调用 **匿名对象** 的析构函数
>
> PS：怀疑以上结果的话，可以在对上面代码进行反汇编，然后着重看拷贝函数的调用即可。汇编码，太晦涩了，就不贴上来了。

通过以上结果，可知在进行 **右值引用** 时，可以延长临时变量的生命周期（对应第 30 行代码），使得临时变量的生命周期与对临时变量进行右值引用的变量的生命周期一致。同时可以避免对临时变量进行的不必要的拷贝开销。

总结：

右值引用有以下特点：

1. 延长临时变量的生命周期
2. 避免对临时变量进行的不必要的拷贝产生的开销

## 特殊情况

万能引用也可以实现，右值引用中的：延长变量的生命周期、避免不必要的拷贝产生的开销

>const A& a=getA();

但是左值引用不能。因为左值只能引用左值！
***
# 右值引用独立于左值和右值

右值引用，是独立于左值和右值的，即右值引用的所引用的对象，既可以是右值又可以是左值。

```C++
int&& num = 1;
```

num 为左值因为 num 可以取地址、非临时变量、而且 num 是被字面量所初始化的变量，但是 `num` 为右值引用。

## 右值引用的值类型

既然右值引用所引用的对象可以是左值、右值，那么右值引用自身是什么类型呢？即 `int &&` 自身是什么类型呢？

```C++
template<typename T>
void func(T&& t);

func(10);// 右值
int i=1;
func(i);// 左值
```

综上可得，右值引用自身的值类型不确定。右值引用自身的值类型可以为: 右值、左值。



## 右值引用的值类型的确定

```C++
template<typename T>
void func(T&& t); // 未确定

template<typename T>
class RvalType{
    RvalType(RvalType&& rvalues); // 右值
}
```



T&& 的值类型为未定的引用类型（universal reference），需要由模板自动推断来确定。具体的值类型依赖于其所引用的变量 t 的类型。t 为左值 T&& 为左值、t 为右值 T&& 为右值。

而 RvalType&& 的值类型已经确定（6行指定了引用的类型为右值类型的变量，所有其值类型为右值），不用由模板自动推导来确定。

***
# 引用折叠

为了处理由右值引用引出的，左值引用引用左值引用、左值引用引用右值引用、右值引用与左值引用、右值引用引用右值引用……的情况，C++ 11 中规定了引用折叠时的规则，以方便确定复杂引用时的表达式的值类型。

## 引用折叠的规则

右值引用叠加到右值引用上，仍然为右值引用。

其他类型的引用叠加到左值引用上，为左值引用。

```C++
int &&a=10;
int &b=a; // 左值引用
int &&b =a; // 右值引用
int &&c=b; // 左值引用
```


