---
title: 插入排序
date: 2020-04-14 22:17:31
author: 佚
categories:
- 数据结构与算法
- 排序
tags:
- 插入排序
---
# 插入排序
插入排序可以近似的看作是 `冒泡排序` 的优化版本.
优化的地方:
- 冒泡排序每趟比较,需要完整的遍历整个数组
- 插入排序,每趟比较,只要将新元素与已经有序的部分进行插入排序即可.

并且插入排序有着自身的优势: **可以有效的利用输入数组的初始状态**
如果输入的数组是有序的,那么插入排序只用进行 `N - 1` 次比较即可.
<!--more-->
## 插入排序与选择排序的区别

1. 插入排序可以有效的利用输入数组的初始状态,选择排序不可
2. 选择排序每趟比较后,可以保证有序的数组不会再在内部进行比较.插入排序不可.

## 插入排序与选择排序的共同点

1. 外循环均是标识当前数组中左侧有序的元素的个数
2. 内循环均是使用右侧的元素,与左侧有序的元素进行比较

# API 设计
和选择排序一样,插入排序依旧使用通用的排序 API.
原因: 数组的排序,无非是访问数组,比较元素,交换元素.
insert.hpp
```C++
/
// Created by yi on 2020/4/14.
//

#ifndef PART2_INSERT_HPP
#define PART2_INSERT_HPP

#include <iostream>

template<typename T>
class insert {
public:
    static void sort(T arr[], const size_t &&size);

    static bool isSorted(T arr[]);

    static bool less(T v, T w);

    static void exch(T arr[], const int &i, const int &j);

    void show(T arr[], const size_t &&size);

};

```

## 实现
insert.hpp
```C++
/**
 * 进行插入排序
 * @tparam T 传入排序的数组的元素的类型
 * @param arr 待排序数组的首地址
 * @param size 待排序数组的大小
 */
template<typename T>
void insert<T>::sort(T *arr, const size_t &&size) {
    for (int i = 1; i < size; ++i) {
        for (int j = i; j > 0 && less(*(arr + j), *(arr + (j - 1))); --j) {
            exch(arr, j, j - 1);
        }
    }
}

/**
 * 判断数组是否有序,PS: 忽略了不定数量相等元素的情况
 * @tparam T 判断是否有序的数组中的元素的类型
 * @param arr 判断是否有序的数组的首地址
 * @return true：有序，false：无序
 */
template<typename T>
bool insert<T>::isSorted(T *arr) {
    T *temp = arr;
    return (*arr < *(++temp));
}

/**
 * 判断给定的两个元素的大小
 * @tparam T 元素的类型
 * @param v 待比较的元素
 * @param w 待比较的元素
 * @return true：v 小于 w，false： v 大于 w
 */
template<typename T>
bool insert<T>::less(T v, T w) {
    return v < w;
}

/**
 * 交换给定的两个元素
 * @tparam T 数组中元素的类型
 * @param arr 数组的首地址
 * @param i 用于交换的元素的索引
 * @param j 用于交换的元素的索引
 */
template<typename T>
void insert<T>::exch(T *arr, const int &i, const int &j) {
    *(arr + i) ^= *(arr + j);
    *(arr + j) ^= *(arr + i);
    *(arr + i) ^= *(arr + j);
}

/**
 * 遍历并打印给定的数组
 * @tparam T 用来遍历的数组中的元素的类型
 * @param arr 数组的首地址
 * @param size 数组中元素的数量
 */
template<typename T>
void insert<T>::show(T *arr, const size_t &&size) {
    for (int i = 0; i < size; ++i) {
        std::cout << *(arr + i);
        std::cout << " ";
    }
    std::cout << std::endl;
}

#endif //PART2_INSERT_HPP
```
PS: 要注意内层循环.内存循环是逆序访问当前有序的数组,然后用当前选中的元素,去与当前有序的数组内进行选择排序

## 测试
```C++
#include "insert.hpp"
using namespace std;

int main() {
    int arr[4] = {2, 3, 1, 4};
    auto *test = new insert<int>;
    insert<int>::sort(arr, 4);
    test->show(arr, 4);
    if (insert<int>::isSorted(arr)){
        cout<<"true"<<endl;
    }
}
```

```
结果:
1 2 3 4
true
```

## 总结
在排序的时候,逆向利用了插入排序.
