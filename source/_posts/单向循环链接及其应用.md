---
title: 单向循环链接及其应用
date: 2020-04-05 17:25:18
author: 佚
copyright: true
categories:
- 数据结构与算法
tags:
- 链表
- 使用
---
# 单向循环链表
在解决圆桌问题时,单向循环链表是一种非常合适的数据结构.
因为,他可以循环计数.

# 节点设计
节点需要两个元素:

1. 数据域: 存放数据
2. 指针域: 存放下一个节点的地址
    - 链表为空时,头节点指向自己
3. 1.2 均为私有,防止数据的意外修改
4. 添加链表类为友元,实现链表对节点的操作
<!--more-->
## 节点的实现
node.hpp

```C++
//
// Created by yi on 2020/4/6.
//

#ifndef PART1_NODE_HPP
#define PART1_NODE_HPP

template <typename T> class circleList;
template<typename T>
class Node{
public:
    friend class circleList<T>;
    Node(): m_pnext(nullptr){

    }

    explicit Node(const T data, Node<T>* m_pnext= nullptr): m_data(data), m_pnext(m_pnext){

    }

    ~Node(){
        m_pnext= nullptr;
    }

private:
    T m_data;
    Node<T>* m_pnext;
};

#endif //PART1_NODE_HPP
```

### 设计思路

有参构造函数,可以将数据域用 **引用** 实现.这儿没采用引用的原因,方便使用字面量来赋值.

节点的构造函数,采用了初始化列表,提高类的实例华效率. explicit 关键字,则说明了该函数只能用于构造函数.

# 链表 API 封装
API 封装的思路:

1. 创建头节点
2. 为链表添加数据
3. 获取链表的长度
4. 判断链表是否为空
5. 根据索引获取对应节点的值
6. 根据索引移除对应位置节点
5. 清空链表

## 链表实现
circleList.hpp

```C++
//
// Created by yi on 2020/4/6.
//

#ifndef PART1_CIRCLELIST_HPP
#define PART1_CIRCLELIST_HPP

#include <cstdio>
#include <iostream>
#include "node.hpp"

/**
 *
 * @tparam T 链表中节点存放的元素的类型
 * @emptyList 清空链表
 * @size 获取链表的长度
 * @add 添加元素
 * @find 找到第 n 个元素并返回（指针，修改会影响到链表中的元素）
 * @del 删除第 n 个元素
 * @get 获取第 n 个元素（拷贝，修改该变量不会影响链表中的元素）
 * @print 遍历打印当前链表
 */

template<typename T>
class circleList {
public:
    explicit circleList(T data) {
        m_head = new Node<T>(data);
        m_head->m_data = data;
        m_head->m_pnext = m_head;
    }

    ~circleList() {
        delete m_head;
    }


public:
    virtual size_t size();

    bool insert(T data, int index = 0);// data,index 不使用引用的原因，避免使用的时候传入了字面量，导致程序崩溃。

    T find(int n);

    bool del(int n);

    void emptyList();

public:
    Node<T> *m_head;
};

/**
 *  不返回指针的原因：  1. 返回指针在该处断码执行完毕后，在栈上的元素会被释放，导致指针空悬,所以返回变量的拷贝
 *                  2. Node 中的数据域为私有，需要返回拷贝，可以让外界取得所需的值，又不影响到原始的链表中的数据
 * @tparam T
 * @param n
 * @return
 */
template<typename T>
T circleList<T>::find(int n) {
    if (0 > n || n > size()) {
        exit(1);
    }

    Node<T> *tem = m_head;
    for (int i = 0; i < n; ++i) {
        tem = tem->m_pnext;
    }
    return tem->m_data;
}

template<typename T>
bool circleList<T>::del(int n) {
    /* n 不能等于 0 ，留下头节点备用*/
    if (0 >= n || n > size()) {
        return false;
    }

    Node<T> *tem = m_head;
    Node<T> *delTem = nullptr;
    for (int i = 0; i < n - 1; ++i) {
        tem = tem->m_pnext;
    }
    delTem = tem->m_pnext;
    tem->m_pnext = delTem->m_pnext;
    delete delTem;
    return true;
}

template<typename T>
void circleList<T>::emptyList() {
    Node<T> *delNode = nullptr;
    Node<T> *curNode = m_head->m_pnext;

    while (curNode->m_pnext != m_head) {
        delNode = curNode;
        curNode = curNode->m_pnext;
        delete delNode;
    }
    m_head->m_pnext = m_head;
}

/**
 * @tparam T
 * @param data
 * @param index
 * @return
 */
template<typename T>
bool circleList<T>::insert(T data, int index) {
    if (0 > index || index > size()) {
        // 越界
        return false;
    }

    Node<T> *tem = m_head;
    auto *newNode = new Node<T>(data);

    for (int i = 0; i < index; ++i) {
        tem = tem->m_pnext;
    }

    newNode->m_pnext = tem->m_pnext;
    tem->m_pnext = newNode;
    return true;
}

template<typename T>
size_t circleList<T>::size() {
    /* 只有头节点的情况 */
    size_t size = 0;
    if (m_head->m_pnext == m_head) {
        return ++size;
    }

    Node<T> *tem = m_head->m_pnext;
    while (tem != m_head) {
        tem = tem->m_pnext;
        ++size;
    }
    return size;
}

#endif //PART1_CIRCLELIST_HPP
```

### 设计思路
1. 当链表数据量足够大时,可以采用添加一个 `size_t` 类型的成员变量,`m_size` 来存储链表的长度.只需要在每次 **添加**, **删除** 数据时,对 `m_size` 进行更新即可.(推荐使用)
2. 链表添加节点时,可以采用引用传递.上述代码未使用引用传递的原因: 为了方便使用字面量进行赋值.
3. 防止链表二次释放,(链表调用 emptyList(),清空一次链表,调用析构函数时再次调用 emptyList()),需要在析构函数中添加链表的长度判断.
4. 调用 emptyList(),清空链表时,在清空了所有元素后,需要对头节点,进行再次初始化(即,头节点的指针域,指针自身).防止后序操作出现问题.
5. 插入元素时的边界问题:
    1. 可采用 `size_t` 类型的索引,来规避部分左边界判断.
    2. 插入的索引,不可大于当前链表的长度.
    3. 链表插入,默认是从头节点下一个开始进行插入的.

6. 获取链表元素时的边界问题:
    1. 可采用 `size_t` 类型的索引,来规避部分左边界判断.
    2. 获取元素的索引,不可大于当前链表的长度.

7. 删除元素时的边界问题:
    1. 传入的元素索引不能为 0,规避删除头节点的风险
    2. 传入的元素索引,不能大于链表的长度

### 测试
main.cpp
```C++
 using namespace std;

int main(int argc, char *argv[]) {
    auto* myList=new circleList<int>(0);
    for (int i = 0; i < 10; ++i) {
        myList->insert(i*2,i);
    }
    cout<<myList->size()<<endl;
    for (int j = 0; j < 5; ++j) {
       myList->del(j+1);
    }
    cout<<myList->size()<<endl; // 输出 5
    myList->emptyList();
    cout<<myList->size()<<endl; //  输出 1 ，因为只剩下头节点

    for (int i = 0; i < 10; ++i) {
        myList->insert(i*2,i);
    }
    cout<<myList->size()<<endl; // 输出 10

    auto tem=new circleList<int>(1);
    cout<<tem->size()<<endl;
}
```

# 用单向循环链表实现队列
这个很简单,只有一个注意点,这个注意点还是自己强行加上的.就是: 在 circleList 中将 size() 声明为虚函数,然后在 queue 中继承时,重写该虚函数即可.

## API 设计

1. 创建队列(先调用父类的构造函数,用头节点标识:空队列)
2. 将元素入队
3. 移除元素
4. 将元素出队
5. 获取队列的长度
6. 清空队列

## 实现
queue.hpp

```C++
//
// Created by yi on 2020/4/8.
//

#ifndef PART1_QUEUEWITHCIRCLELIST_HPP
#define PART1_QUEUEWITHCIRCLELIST_HPP

#include "circleList.hpp"

template<typename T>
class queueWithcircleList :  public circleList<T>{
public:
    queueWithcircleList();

    explicit queueWithcircleList(T data) : m_data(data) {

    }

    bool push(T data);

    bool pop();

    T top();

    void emptyQueue();

    size_t size();

    ~queueWithcircleList() = default;

private:
    T m_data;
};

template<typename T>
queueWithcircleList<T>::queueWithcircleList() {

}

template<typename T>
bool queueWithcircleList<T>::push(T data) {
    int size = circleList<T>::size();
    return circleList<T>::insert(data, size + 1);
}

template<typename T>
bool queueWithcircleList<T>::pop() {
    return circleList<T>::del(1);
}

template<typename T>
T queueWithcircleList<T>::top() {
    return circleList<T>::find(1);
}

template<typename T>
size_t queueWithcircleList<T>::size() {
    return circleList<T>::size();
}

template<typename T>
void queueWithcircleList<T>::emptyQueue() {
    circleList<T>::emptyList();
}
#endif //PART1_QUEUEWITHCIRCLELIST_HPP
```

## 测试

```C++
int main(int argc, char *argv[]) {
    auto*p=new queueWithcircleList<int>();
    for (int i = 0; i < 10; ++i) {
       p->push(i);
    }
    cout<<p->size()<<endl;
    cout<<p->top()<<endl;
    p->pop();
    cout<<p->top()<<endl;
    p->emptyQueue();
    return 0;
}
```
# Josephus
尽量不要使用带头节点的循环链表来处理 Josephus 问题,否则的话会遇到相当多的关于循环时头节点的问题.大大增加逻辑的复杂性,造成程序的可读性严重下降.


用 C 语言来处理会更简单.不推荐用上面封装的 C++ 代码来进行处理.因为上面的 C++ 代码,无法手动控制链表.只能用封装好的 API 来进行控制.
如果强行的控制的话,会有一个 bug,就是循环链表中的头节点更换后,处理尾节点的指向,无法处理(当然也不是无法处理,处理后就像是强行用 C 来控制 C++,没有美感)

所以直接用 C 代码来进行处理.
要求: Josephus问题。在这个古老的问题中,N 个身陷绝境的人一致同意通过以下方式减少生存人数。他们围坐成一圈(位置记为 0 到 N-1)并从第一个人开始报数,报到 M 的人会被杀死, 直到最后一个人留下来。传说中 Josephus 找到了不会被杀死的位置。编写一个 Queue的用例Josephus, 从命令行接受 N 和 M 并打印出人们被杀死的顺序 (这也将显示 Josephus 在圈中的位置) 。

## 思路

1. 建立循环链表
2. 分别取出待删除元素和待删除元素的前一个元素
3. 移除元素
4. 更新下次计数开始的节点
PS: 需要注意的是 2 步.待删除节点和待删除节点的前一个节点是同时取得的.

### 实现
Josephus
```C
typedef struct node {
    int data;
    struct node *pnext;
} Node1;

void JOSEPHUS(int size, int killer) {
    Node1 *tail, *head;
    head = NULL;
    // 建立循环链表
    for (int i = 0; i < size; i++) {
        Node1 *newNode = (Node1 *) malloc(sizeof(Node1));
        newNode->data = i;
        newNode->pnext = NULL;
        if (NULL == head) {
            /* 链表中只有一个节点的时候，头尾节点指定同一个节点 */
            newNode->pnext = newNode;
            head = newNode;
            tail = newNode;
        } else {
            tail->pnext = newNode;
            newNode->pnext = head;
            tail = newNode;
        }
    }

    Node1 *kill = head;
    Node1 *temp = NULL;
    /*将报到指定数字的人，移除队列*/
    while (kill->pnext != kill) {
        for (int k = 0; k < killer - 1; k++) {
            temp = kill;
            kill = kill->pnext;
        }
        temp->pnext = kill->pnext; /*将出队的元素的前一个元素，指向出队元素的下一个元素*/
        temp=kill->pnext; /* 更新循环开始的地方 */
        printf("Delete number: %d\n", kill->data);   // 打印所要删除结点的数据
        free(kill);                      // 删除结点，从内存释放该结点占用的内存空间
        kill = temp;
    }
    printf("The last one is No.%d\n", kill->data);
}

#endif //PART1_JOSEPHUS_H

```

### 测试
```C++
int main(int argc, char *argv[]) {
   int size,remove;
   cin >> size;
   cin.get();
   cin>>remove;
   JOSEPHUS(size,remove);
   return 0;
}
```
case: 
```
7 2
1   3   5   0   4   2   6
```
