---
title: 单向循环链接及其应用
date: 2020-04-05 17:25:18
author: 佚
copyright: true
categories:
- 数据结构与算法
tags:
- 链表
- 使用
---

# 单向循环链表
在解决圆桌问题时,单向循环链表是一种非常合适的数据结构.
因为,他可以循环计数.

# API 封装
API 封装的思路:

1. 创建定长的链表
2. 为链表添加数据
3. 获取链表的头、尾节点
4. 判断链表是否为空

<!--more-->
下面的代码思路是错误的,正确代码在最后面.
这两天抽空会补充下正确代码的设计思路.
circleList.h

```C++
//
// Created by yi on 2020/4/5.
//

#ifndef PART1_CIRCLELIST_H
#define PART1_CIRCLELIST_H

#include <cstddef>

/**
 * @param data 存放的数据
 * @param next 指向节点的指针
 */
typedef struct node{
   int data;
   node* next;
} Node;

/**
 * @param m_node 链表中的节点
 * @param m_head 链表的头节点
 * @param m_tail 链表的尾节点
 * @param m_current 链表当前待初始化节点
 * @param m_size 链表中当前元素的数量
 * @param m_capcities 链表的总容量
 * @func  getHead() 获取链表的头节点指针
 * @func  getTail() 获取链表的尾节点指针
 * @func  isEmpty() 判断链表是否为空
 */
class circleList {
public:
    node* getHead();
    node* getTail();
    bool isEmpty();
    bool set(int data); // 不使用引用是为了方便直接使用字面量
    explicit circleList(const size_t& size);
    ~circleList();

public:
    node* m_node;

private:
   node* m_head;
   node* m_tail;
   node* m_current;
   size_t m_size;
   size_t m_capcities;
};
#endif //PART1_CIRCLELIST_H
```

# 代码实现
circleList.cpp

```C++
//
// Created by yi on 2020/4/5.
//

#include "circleList.h"

node *circleList::getHead() {
    return m_head;
}

bool circleList::isEmpty() {
    return m_tail == m_head;
}

node *circleList::getTail() {
    return m_tail;
}

/**
 * @param size 创建的链表的长度
 * 为了，简化操作，优化频繁操作的效率，减少内存碎片化。不使用传统的节点拼接来创建链表的方式，直接申请一块连续的内存来进行操作
 * 同时，在简单场景下，可以忽略内存池的配置
 */
circleList::circleList(const size_t &size) {
    auto *node = new Node[size+1];
    m_head = node;
    m_tail = node;
    m_capcities = size;
    m_size = 0;
    m_current = ++node; // 连续内存空间，且元素定长，可以直接通过指针 ++ 来进行节点的更新操做
    m_node = node;
}

circleList::~circleList() {
    for (int i = 0; i < m_size; ++i) {
        m_current=m_head->next;
        delete m_head;
        m_head=m_current;
    }
}

/**
 * 采用尾插法，避免每次插入时大量移动数据,头节点不存放数据
 * @param data 插入链表节点的数据
 * @return 数据是否插入成功 true: 插入成功，false 插入失败
 */
bool circleList::set(int data) {
    if (m_size == m_capcities) {
        return false;
    }

    m_node = m_current;
    m_node->data = data;
    m_node->next = nullptr;
    ++m_current;
    ++m_tail;
    m_tail->next = m_head;
    ++m_size;
    return true;
}
```

## 实现思路

1. 头节点的数据无意义,无需初始化
2. 申请定长的空间,便于使用 `++` 等语法糖,对指针进行操作
3. 判空条件: 头尾节点指向的节点相等.
4. 非空条件下: 尾节点的指针域,指向头节点
5. `m_current` 指向待初始化的节点位置(初始化时,指向头节点的下一个节点)
6. 采用尾插法,因为维护了 `m_current` 指针,可以避免每次插入时需要的大量遍历操作
7. 不采用头插法的原因: 因为是 `连续的内存空间` ,使用头插法时,需要大量的移动数据.造成效率太低.

# 正确的代码
node.hpp

```C++
//
// Created by yi on 2020/4/6.
//

#ifndef PART1_NODE_HPP
#define PART1_NODE_HPP

template <typename T> class circleList;
template<typename T>
class Node{
public:
    friend class circleList<T>;
    Node(): m_pnext(nullptr){

    }

    explicit Node(const T data, Node<T>* m_pnext= nullptr): m_data(data), m_pnext(m_pnext){

    }

    ~Node(){
        m_pnext= nullptr;
    }

private:
    T m_data;
    Node<T>* m_pnext;
};

#endif //PART1_NODE_HPP
```

circleList.hpp
```
//
// Created by yi on 2020/4/6.
//

#ifndef PART1_CIRCLELIST_HPP
#define PART1_CIRCLELIST_HPP

#include <cstdio>
#include <iostream>
#include "node.hpp"

/**
 *
 * @tparam T 链表中节点存放的元素的类型
 * @emptyList 清空链表
 * @size 获取链表的长度
 * @add 添加元素
 * @find 找到第 n 个元素并返回（指针，修改会影响到链表中的元素）
 * @del 删除第 n 个元素
 * @get 获取第 n 个元素（拷贝，修改该变量不会影响链表中的元素）
 * @print 遍历打印当前链表
 */
template<typename T>
class circleList {
public:
    circleList() : m_head(new Node<T>()) {
        m_head->m_pnext = m_head;
    }

    ~circleList() {
        // 防止二次调用
        if(size()>0){
            emptyList();
        }
        delete m_head;
    }


public:
    int size();

    bool insert(T data, int index);// data,index 不使用引用的原因，避免使用的时候传入了字面量，导致程序崩溃。

    T find(int n);

    bool del(int n);

    void print();

    void emptyList();

private:
    Node<T> *m_head;
    //size_t m_size;
};

template<typename T>
int circleList<T>::size() {
    int length = 0;
    Node<T> *tem = m_head;

    while (tem->m_pnext != m_head) {
        ++length;
        tem = tem->m_pnext;
    }
    return length;
}

/**
 *  不返回指针的原因：  1. 返回指针在该处断码执行完毕后，在栈上的元素会被释放，导致指针空悬,所以返回变量的拷贝
 *                  2. Node 中的数据域为私有，需要返回拷贝，可以让外界取得所需的值，又不影响到原始的链表中的数据
 * @tparam T
 * @param n
 * @return
 */
template<typename T>
T circleList<T>::find(int n) {
    if (0 > n || n > size()) {
        exit(1);
    }

    Node<T> *tem = m_head;
    for (int i = 0; i < n; ++i) {
        tem = tem->m_pnext;
    }
    return tem->m_data;
}

template<typename T>
bool circleList<T>::del(int n) {
    if (0 >= n || n > size()) {
        return false;
    }

    Node<T> *tem = m_head;
    Node<T> *delTem = nullptr;
    for (int i = 0; i < n - 1; ++i) {
        tem = tem->m_pnext;
    }
    delTem = tem->m_pnext;
    tem->m_pnext = delTem->m_pnext;
    delete delTem;
    return true;
}

template<typename T>
void circleList<T>::print() {

}

template<typename T>
void circleList<T>::emptyList() {
    Node<T> *delNode = m_head;
    Node<T> *curNode = m_head->m_pnext;

    while (curNode->m_pnext != m_head) {
        delNode = curNode;
        curNode = curNode->m_pnext;
        delete delNode;
    }
    m_head->m_pnext=m_head;
}

template<typename T>
bool circleList<T>::insert(T data, int index) {
    if (0 > index || index > size()) {
        // 越界
        return false;
    }

    Node<T> *tem = m_head;
    auto *newNode = new Node<T>(data);
    for (int i = 0; i < index; ++i) {
        tem = tem->m_pnext;
        if (tem == m_head) {
            // 越界
            return false;
        }
    }
    newNode->m_pnext = tem->m_pnext;
    tem->m_pnext = newNode;

    return true;
}

#endif //PART1_CIRCLELIST_HPP
```
