---
title: 单向循环链接及其应用
date: 2020-04-05 17:25:18
author: 佚
copyright: true
categories:
- 数据结构与算法
tags:
- 链表
- 使用
---
# 单向循环链表
在解决圆桌问题时,单向循环链表是一种非常合适的数据结构.
因为,他可以循环计数.

# 节点设计
节点需要两个元素:

1. 数据域: 存放数据
2. 指针域: 存放下一个节点的地址
    - 链表为空时,头节点指向自己
3. 1.2 均为私有,防止数据的意外修改
4. 添加链表类为友元,实现链表对节点的操作

## 节点的实现
node.hpp

```C++
//
// Created by yi on 2020/4/6.
//

#ifndef PART1_NODE_HPP
#define PART1_NODE_HPP

template <typename T> class circleList;
template<typename T>
class Node{
public:
    friend class circleList<T>;
    Node(): m_pnext(nullptr){

    }

    explicit Node(const T data, Node<T>* m_pnext= nullptr): m_data(data), m_pnext(m_pnext){

    }

    ~Node(){
        m_pnext= nullptr;
    }

private:
    T m_data;
    Node<T>* m_pnext;
};

#endif //PART1_NODE_HPP
```

### 设计思路

有参构造函数,可以将数据域用 **引用** 实现.这儿没采用引用的原因,方便使用字面量来赋值.

节点的构造函数,采用了初始化列表,提高类的实例华效率. explicit 关键字,则说明了该函数只能用于构造函数.

# 链表 API 封装
API 封装的思路:

1. 创建头节点
2. 为链表添加数据
3. 获取链表的长度
4. 判断链表是否为空
5. 根据索引获取对应节点的值
6. 根据索引移除对应位置节点
5. 清空链表

## 链表实现
circleList.hpp

```C++
//
// Created by yi on 2020/4/6.
//

#ifndef PART1_CIRCLELIST_HPP
#define PART1_CIRCLELIST_HPP

#include <cstdio>
#include <iostream>
#include "node.hpp"

/**
 *
 * @tparam T 链表中节点存放的元素的类型
 * @emptyList 清空链表
 * @size 获取链表的长度
 * @add 添加元素
 * @find 找到第 n 个元素并返回（指针，修改会影响到链表中的元素）
 * @del 删除第 n 个元素
 * @get 获取第 n 个元素（拷贝，修改该变量不会影响链表中的元素）
 * @print 遍历打印当前链表
 */
template<typename T>
class circleList {
public:
    circleList() : m_head(new Node<T>()) {
        m_head->m_pnext = m_head;
    }

    ~circleList() {
        // 防止二次调用
        if (size() > 0) {
            emptyList();
        }
        delete m_head;
    }


public:
    int size();

    bool insert(T data, int index = 0);// data,index 不使用引用的原因，避免使用的时候传入了字面量，导致程序崩溃。

    T find(int n);

    bool del(int n);

    void emptyList();

private:
    Node<T> *m_head;
    //size_t m_size;
};

template<typename T>
int circleList<T>::size() {
    int length = 0;
    Node<T> *tem = m_head;

    while (tem->m_pnext != m_head) {
        ++length;
        tem = tem->m_pnext;
    }
    return length;
}

/**
 *  不返回指针的原因：  1. 返回指针在该处断码执行完毕后，在栈上的元素会被释放，导致指针空悬,所以返回变量的拷贝
 *                  2. Node 中的数据域为私有，需要返回拷贝，可以让外界取得所需的值，又不影响到原始的链表中的数据
 * @tparam T
 * @param n
 * @return
 */
template<typename T>
T circleList<T>::find(int n) {
    if (0 >= n || n > size()) {
        exit(1);
    }

    Node<T> *tem = m_head;
    for (int i = 0; i < n; ++i) {
        tem = tem->m_pnext;
    }
    return tem->m_data;
}

template<typename T>
bool circleList<T>::del(int n) {
    if (0 >= n || n > size()) {
        return false;
    }

    Node<T> *tem = m_head;
    Node<T> *delTem = nullptr;
    for (int i = 0; i < n - 1; ++i) {
        tem = tem->m_pnext;
    }
    delTem = tem->m_pnext;
    tem->m_pnext = delTem->m_pnext;
    delete delTem;
    return true;
}

template<typename T>
void circleList<T>::emptyList() {
    Node<T> *delNode = m_head;
    Node<T> *curNode = m_head->m_pnext;

    while (curNode->m_pnext != m_head) {
        delNode = curNode;
        curNode = curNode->m_pnext;
        delete delNode;
    }
    m_head->m_pnext = m_head;
}

template<typename T>
bool circleList<T>::insert(T data, int index) {
    if (0 >= index || index > size() + 1) {
        // 越界
        // size +1 是因为忽略了头节点,使得链表长度减少了 1
        return false;
    }

    Node<T> *tem = m_head;
    auto *newNode = new Node<T>(data);

    for (int i = 0; i < index - 1; ++i) {
     // index - 1 是因为忽略了头节点,使得链表长度减少了 1
        tem = tem->m_pnext;
        /*
        if (tem == m_head) {
            // 越界
            return false;
        }
         */
    }
    newNode->m_pnext = tem->m_pnext;
    tem->m_pnext = newNode;
    return true;
}

#endif //PART1_CIRCLELIST_HPP
```

### 设计思路
1. 当链表数据量足够大时,可以采用添加一个 `size_t` 类型的成员变量,`m_size` 来存储链表的长度.只需要在每次 **添加**, **删除** 数据时,对 `m_size` 进行更新即可.(推荐使用)
2. 链表添加节点时,可以采用引用传递.上述代码未使用引用传递的原因: 为了方便使用字面量进行赋值.
3. 防止链表二次释放,(链表调用 emptyList(),清空一次链表,调用析构函数时再次调用 emptyList()),需要在析构函数中添加链表的长度判断.
4. 调用 emptyList(),清空链表时,在清空了所有元素后,需要对头节点,进行再次初始化(即,头节点的指针域,指针自身).防止后序操作出现问题.
5. 插入元素时的边界问题: 
    1. 可采用 `size_t` 类型的索引,来规避部分左边界判断.
    2. 插入的索引,不可大于当前链表的长度.
    3. 链表插入,默认是从头节点下一个开始进行插入的.

6. 获取链表元素时的边界问题:
    1. 可采用 `size_t` 类型的索引,来规避部分左边界判断.
    2. 获取元素的索引,不可大于当前链表的长度.
    3. 不可获取索引为 0 的元素:头节点(数据无意义)

7. 删除元素时的边界问题:
    1. 传入的元素索引不能为 0,规避删除头节点的风险
    2. 传入的涌入索引,不能大于链表的长度
