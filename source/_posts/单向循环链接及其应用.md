---
title: 单向循环链接及其应用
date: 2020-04-05 17:25:18
author: 佚
copyright: true
categories:
- 数据结构与算法
tags:
- 链表
- 使用
---

# 单向循环链表
在解决圆桌问题时,单向循环链表是一种非常合适的数据结构.
因为,他可以循环计数.

# API 封装
API 封装的思路:

1. 创建定长的链表
2. 为链表添加数据
3. 获取链表的头、尾节点
4. 判断链表是否为空

<!--more-->
circleList.h

```C++
//
// Created by yi on 2020/4/5.
//

#ifndef PART1_CIRCLELIST_H
#define PART1_CIRCLELIST_H

#include <cstddef>

/**
 * @param data 存放的数据
 * @param next 指向节点的指针
 */
typedef struct node{
   int data;
   node* next;
} Node;

/**
 * @param m_node 链表中的节点
 * @param m_head 链表的头节点
 * @param m_tail 链表的尾节点
 * @param m_current 链表当前待初始化节点
 * @param m_size 链表中当前元素的数量
 * @param m_capcities 链表的总容量
 * @func  getHead() 获取链表的头节点指针
 * @func  getTail() 获取链表的尾节点指针
 * @func  isEmpty() 判断链表是否为空
 */
class circleList {
public:
    node* getHead();
    node* getTail();
    bool isEmpty();
    bool set(int data); // 不使用引用是为了方便直接使用字面量
    explicit circleList(const size_t& size);
    ~circleList();

public:
    node* m_node;

private:
   node* m_head;
   node* m_tail;
   node* m_current;
   size_t m_size;
   size_t m_capcities;
};
#endif //PART1_CIRCLELIST_H
```

# 代码实现
circleList.cpp

```C++
//
// Created by yi on 2020/4/5.
//

#include "circleList.h"

node *circleList::getHead() {
    return m_head;
}

bool circleList::isEmpty() {
    return m_tail == m_head;
}

node *circleList::getTail() {
    return m_tail;
}

/**
 * @param size 创建的链表的长度
 * 为了，简化操作，优化频繁操作的效率，减少内存碎片化。不使用传统的节点拼接来创建链表的方式，直接申请一块连续的内存来进行操作
 * 同时，在简单场景下，可以忽略内存池的配置
 */
circleList::circleList(const size_t &size) {
    auto *node = new Node[size+1];
    m_head = node;
    m_tail = node;
    m_capcities = size;
    m_size = 0;
    m_current = ++node; // 连续内存空间，且元素定长，可以直接通过指针 ++ 来进行节点的更新操做
    m_node = node;
}

circleList::~circleList() {
    for (int i = 0; i < m_size; ++i) {
        m_current=m_head->next;
        delete m_head;
        m_head=m_current;
    }
}

/**
 * 采用尾插法，避免每次插入时大量移动数据,头节点不存放数据
 * @param data 插入链表节点的数据
 * @return 数据是否插入成功 true: 插入成功，false 插入失败
 */
bool circleList::set(int data) {
    if (m_size == m_capcities) {
        return false;
    }

    m_node = m_current;
    m_node->data = data;
    m_node->next = nullptr;
    ++m_current;
    ++m_tail;
    m_tail->next = m_head;
    ++m_size;
    return true;
}
```

## 实现思路

1. 头节点的数据无意义,无需初始化
2. 申请定长的空间,便于使用 `++` 等语法糖,对指针进行操作
3. 判空条件: 头尾节点指向的节点相等.
4. 非空条件下: 尾节点的指针域,指向头节点
5. `m_current` 指向待初始化的节点位置(初始化时,指向头节点的下一个节点)
6. 采用尾插法,因为维护了 `m_current` 指针,可以避免每次插入时需要的大量遍历操作
7. 不采用头插法的原因: 因为是 `连续的内存空间` ,使用头插法时,需要大量的移动数据.造成效率太低.
