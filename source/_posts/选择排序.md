---
title: 选择排序
date: 2020-04-13 22:29:24
author: 佚
copyright: true
categories: 
- 数据结构与算法
tags:
- 选择排序
- 位运算
---
# 选择排序
选择排序是一种非常常见的排序算法.他具有一个别的算法都不具备的优点特性:
**移动元素的次数最少**,一共交换了 N 次.(用来排序的数组的大小)
同时,他有也一个特有的缺点特性:
**无法利用输入元素的初试状态** 即使输入的元素有序,他依然会从头到位一步不少的执行一遍自己的排序步骤.

<!--more-->
# API 设计

API 设计为,所有的排序算法通用的接口.从中可以抽象出排序算法的基本操作: 比较元素大小,交换元素.

1. 进行排序
2. 判断给出的数组是否有序
3. 判断元素的大小
4. 交换给定的两个元素
5. 遍历输出给定的数组

select.hpp
```C++
//
// Created by yi on 2020/4/11.
//

#ifndef PART2_SELECT_H
#define PART2_SELECT_H

#include <iostream>


template<typename T>
class select {
public:
    static void sort(T arr[],  const size_t &&size);

    static bool isSorted(T arr[], const size_t &&size);

    static bool less(T v, T w);

    static void exch(T arr[], const int& i, const int& j);

    void show(T arr[], const size_t &&size);
};
```

## 实现
select.hpp
```C++
/**
 * 进行选择排序
 * @tparam T 传入排序的数组的元素的类型
 * @param arr 待排序数组的首地址
 * @param size 待排序数组的大小
 */
template<typename T>
void select<T>::sort(T *arr, const size_t &&size) {
    for (int i = 0; i < size - 1; ++i) {
        for (int j = i + 1; j < size; ++j) {
            if (less(*(arr + j), *(arr + i))) {
                exch(arr, i, j);
            }
        }
    }
}

/**
 * 判断数组是否有序,PS: 忽略了不定数量相等元素的情况
 * @tparam T 判断是否有序的数组中的元素的类型
 * @param arr 判断是否有序的数组的首地址
 * @return true：有序，false：无序
 */
template<typename T>
bool select<T>::isSorted(T *arr, const size_t &&size) {
    T *temp = arr;

    /*数组中的所有元素都相等*/
    if (*arr == *(temp + size)) {
        return true;
    }

    return *arr < (*(++temp));
}

/**
 * 判断给定的两个元素的大小
 * @tparam T 元素的类型
 * @param v 待比较的元素
 * @param w 待比较的元素
 * @return true：v 小于 w，false： v 大于 w
 */
template<typename T>
bool select<T>::less(T v, T w) {
    return v < w;
}

/**
 * 交换给定的两个元素
 * @tparam T 数组中元素的类型
 * @param arr 数组的首地址
 * @param i 用于交换的元素的索引
 * @param j 用于交换的元素的索引
 */
template<typename T>
void select<T>::exch(T *arr, const int& i, const int& j) {
    *(arr + i) ^= *(arr + j);
    *(arr + j) ^= *(arr + i);
    *(arr + i) ^= *(arr + j);

}

/**
 * 遍历并打印给定的数组
 * @tparam T 用来遍历的数组中的元素的类型
 * @param arr 数组的首地址
 * @param size 数组中元素的数量
 */
template<typename T>
void select<T>::show(T *arr, const size_t &&size) {
    for (int i = 0; i < size; ++i) {
        std::cout << *arr + i;
        std::cout << " ";
    }
    std::cout << std::endl;
}

#endif //PART2_SELECT_H
```
PS:
利用位运算交换元素的理解:
```
假设 a = 1;
b = 0;
a ^= b  --> 0001 ^= 0000 --> 0001 用 a 保存 两数字二进制不等的地方
b ^= a  --> 0000 ^= 0001 --> 0001 用 b 取出  a
a ^= b  --> 0001 ^= 0001 --> 0000 用 a 取出 b
利用了 门电路中的 异或门 的特性
```

## 测试
```C++
#include "select.hpp"

using namespace std;

int main() {
    int arr[4] = {2, 3, 1, 4};
    auto *test = new select<int>;
    select<int>::sort(arr, 4);
    test->show(arr, 4);
    if (select<int>::isSorted(arr, 4)) {
        cout << "有序" << endl;
    }

    int same[3] = {1, 1, 1};
    if (select<int>::isSorted(same,3)){
        cout << "有序" << endl;
    }
}
```

### 总结
选择排序的实现,利用了快慢指针的思想.快慢指针的变种可以是多种多样的,比如:
`给定两个数组,通过遍历来找出数组中最小、最大的元素`
- 选择排序的外循环: 慢指针
- 选择排序的内循环: 快指针

通过快慢指针的终止状态,可以实现排序,查找最大最小元素.
- 升序: 快指针的终止状态: 当前无序数组中的最大元素
- 降序: 快指针的终止撞停: 当前无序数组中的最小元素
- 升序: 慢指针的终止状态: 当前数组为升序
- 降序: 慢指针的终止撞动态: 当前数组为降序
