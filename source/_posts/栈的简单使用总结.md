---
title: 栈的简单使用总结
date: 2020-04-04 22:57:42
author: 佚
copyright: true
categories: 数据结构与算法
tags:
- 栈
- 使用
---

# 栈结构的常见使用
得益于栈结构的简单性，栈是很多高级算法的基础。有着丰富的应用。

常见的使用：
  -  0x01. 队列的逆序输出
  -  0x02，求数值的二进制运算
  -  0x03. dijkstra 算法解决四则运算问题
  -  0x04. dijkstra 算法解决括号匹配问题
  -  0x05. 数学表达式的中序变后序转化


## 队列的逆序输出
队列的逆序输出，使用栈来实现是最简单，最容易让人理解的。

<!-- more -->

### 思路
队列：FIFO
栈：FILO

- 0x01. 将队列中的元素依次出队，并依次压入栈中。
- 0x02. 栈中的元素依次弹栈

完美的结合利用了，这两种简单的数据结构的特性。进而实现了队列的逆序输出

### 实现
太简单了，只写伪代码：

```C++
queue<type> que;
stack<type> sta;
while(!que.empty()){
    sta.push(que.top());
    que.deque();
}
```
上述伪代码，利用栈实现了队列的逆序。

## 求数值的二进制运算
也是非常基础的栈的应用,只是思路不易让人想到. 是收到数学计算数值的二进制,得到的启发.

### 思路
- 0x01. 对数值 A 进行求解二进制.
- 0x02. 对 A 进行模 2 运算.并将结果入栈.
- 0x03. A = A / 2
- 0x04. 判断出口条件
- 0x05. 完成

PS: 思路看起来不容易理解,可以试着随便做一个数值的二进制转化,看下计算过程.
能加深对 0x02, 0x03 的理解.

### 实现
过于简单,放伪代码

```C++
stack<int> sta;
int num = 10;
while(num>0){
    sta.push(num%2);
    num /= 2;
}

while(!sta.empty()){
    cout<<sta.top();
    sta.pop();
}
cout<<endl;
```


## dijkstra 算法解决四则运算
利用 dijkstra 算法来处理四则运算，是栈的高级应用的基础。

### 思路
- 0x01. 创建两个用于存放操作符和操作数的栈
- 0x02. 将表达式的 `操作符` ,`操作数` 分别压入对应栈中
    - 1. 操作符入栈时,忽略左括号
    - 2. 操作符入栈时,遇到右括号停止入栈(或,在 0x04 完成后,再入栈)
- 0x03. 从 `操作符栈` 中取出操作符,并从 `操作数栈` 中取出操作符所需数目的操作数
- 0x04. 将计算结果压入 `操作数栈` 中,并弹出 `操作符栈` 中的操作符,继续 0x02-0x04
- 0x05. 得到结果

### 实现
dijkstra.h
```C++
#ifndef LEARNA_DIJKSTRA_H
#define LEARNA_DIJKSTRA_H

#include <string>

class dijkstra {
public:
    explicit dijkstra(std::string input);
    ~dijkstra();
    int result();
private:
    std::string m_origin_string;
};


#endif //LEARNA_DIJKSTRA_H
```

dijkstra.cpp
```C++
#include <utility>

//
// Created by _yi on 2020/1/4.
//

#include "dijkstra.h"
#include <stack>
#include <iostream>

dijkstra::dijkstra(std::string input) {
    m_origin_string = std::move(input);
}

dijkstra::~dijkstra() = default;


int dijkstra::result() {
    // 获取一个含运算符和操作数的字符串
    std::stack<char> operator_stack;
    std::stack<int> alp_stack;
    // 忽略左括号
    for (auto s :m_origin_string) {
        /** 将运算符压入运算符栈**/
        if ('(' == s) {
            continue;
        } else if ('+' == s) {
            operator_stack.push(s);
        } else if ('-' == s) {
            operator_stack.push(s);
        } else if ('*' == s) {
            operator_stack.push(s);
        } else if ('/' == s) {
            operator_stack.push(s);

        }
            /**
             * 从 operator_stack 中取出运算符和运算符所需数量的操作数
             * 计算完毕后，从 alp_stack 中移除已经使用过的操作数
             * 并将计算后的结果压入 alp_stack
             **/
        else if (')' == s) {
            char operaton_char = operator_stack.top();
            operator_stack.pop();
            int num = alp_stack.top();
            alp_stack.pop();
            if ('+' == operaton_char) {
                num = num + alp_stack.top();
                alp_stack.pop();
            } else if ('-' == operaton_char) {
                num = num - alp_stack.top();
                alp_stack.pop();

            } else if ('*' == operaton_char) {

                num = num * alp_stack.top();
                alp_stack.pop();
            } else if ('/' == operaton_char) {
                num = num / alp_stack.top();
                alp_stack.pop();
            }
            alp_stack.push(num);
        }
            /** 将数字压入alp_stack**/
        else {
            alp_stack.push(static_cast<int>(s) - 48);
        }
    }
    return alp_stack.top();
}
```

## dijkstra 算法解决括号匹配问题
该场景有两个复杂程度不可同日而语的场景:
- 简单的: 判断括号是否匹配
- 复杂的: 将缺失的括号,按照规则补全
*注意* 复杂的来题目自算法第四版: 1.3.9 习题

### 思路
- 简单的:
    - 将表达的操作符依次入栈,直到遇到第一个右括号
    - 判断操作符栈,栈顶元素是否与右括号匹配.匹配: 正确,继续执行,不匹配,错误.跳出执行

- 复杂的:
  - 0x01. 创建两个栈,一个存放 `操作符`,一个存放`操作数`
  - 0x02. 操作符入栈时以 `右括号` 为哨兵.
  - 0x03. 遇到哨兵,则依次取出操作符,和操作符所需的操作数
  - 0x04. 组合表达式(添加左右括号)
  - 0x05. 将表达式操作数栈
  - 0x06. 0x02 - 0x05,直到达到循环出口条件

### 实现
简单的:

```C++
/*
 * 忽略了异常的状态：输入为非法字符
 * 思路：将标准输入中的所有左括号放入栈中，然后读取到右括号后从栈顶取出元素进行比较
 * 1 异常：左括号的数量比右括号数量多
 * 2 异常：右括号的数量比左括号数量多
 */
bool parentheses() {
    char input;
    bool result = false;
    std::stack<char> parentheses;

    while (std::cin >> input) {
        if (input == '(' || input == '[' || input == '{') {
            parentheses.push(input);
        } else {
            // 符号匹配处理
            if (input == ')') {
                if (parentheses.top() != '(') {
                    return false;
                }
                result = true;
            } else if (input == ']') {
                if (parentheses.top() != '[') {
                    return false;
                }
                result = true;
            } else if (input == '}') {
                if (parentheses.top() != '{') {
                    return false;
                }
                result = true;
            }

            // 出栈及异常处理
            if (!parentheses.empty()) {
                parentheses.pop();
            } else {
                // 左括号比右括号数量多的情况
                return false;
            }
        }
    }

    // 异常处理
    if (!parentheses.empty()) {
        // 右括号比左括号数量多的情况
        return false;
    }
    return result;
}
```

case1: 正确的
```
echo "{[()]}“ | ./main
输出: 1
```

case2: 错误的
```
echo "(()" | ./main
输出: 0
```

复杂的
```C++
/*
 * 思路：由于栈的出栈顺序是逆序的，而左右括号又是自己添加的。所以要逆序添加括号。
 * 采用 dijkstra 算法。由于 C++ 字符转 string 有很多不便，故而添加了个存放结果的栈
 * 1 操作符入栈
 * 2 操作数入栈
 * 3 添加 + - 运算表达式的括号，组合表达式。在 + - 表达式组合完成后，操作符栈内只余下 * / 等运算
 * 4 从 result 栈（string）中取出组合好的 + - 表达式，进行复杂表达式的构建
 * 5 逆序输出结果
 */
void autoParent() {
    std::stack<char> vals;
    std::stack<std::string> result;
    std::stack<char> oprs;
    std::string exp;
    char input;
    char leftNum;
    char rightNum;

    while (std::cin >> input) {
        // 操作符入栈
        std::string temExp;
        if (input < '0' && input != ')') {
            oprs.push(input);
        } else if (input >= '0') {
            // 操作数入栈
            vals.push(input);
        } else if (input == ')') {
            // 操作符，操作数出栈，拼接新字符串,并入操作数栈
            if (!vals.empty()) {
                rightNum = vals.top();
                vals.pop();
                leftNum = vals.top();
                vals.pop();
                temExp.push_back(')');
                temExp.push_back(rightNum);
                temExp.push_back(oprs.top());
                temExp.push_back(leftNum);
                temExp.push_back('(');
                oprs.pop();
                result.push(temExp);
            } else {
                temExp.push_back(')');
                temExp+=result.top();
                result.pop();
                temExp+=oprs.top();
                oprs.pop();
                temExp+=result.top();
                result.pop();
                temExp.push_back('(');
                result.push(temExp);
            }
        }
    }

    exp=result.top();
    std::reverse(std::begin(exp), std::end(exp));
    std::cout<<exp<<std::endl;
}
```

case:
```
echo "1+2)*3-4)*5-6)))" | ./main
输出: ((1+2)*((3-4)*(5-6)))
```
