<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[插入排序]]></title>
    <url>%2F2020%2F04%2F14%2F%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[插入排序插入排序可以近似的看作是 冒泡排序 的优化版本.优化的地方: 冒泡排序每趟比较,需要完整的遍历整个数组 插入排序,每趟比较,只要将新元素与已经有序的部分进行插入排序即可. 并且插入排序有着自身的优势: 可以有效的利用输入数组的初始状态如果输入的数组是有序的,那么插入排序只用进行 N - 1 次比较即可. 插入排序与选择排序的区别 插入排序可以有效的利用输入数组的初始状态,选择排序不可 选择排序每趟比较后,可以保证有序的数组不会再在内部进行比较.插入排序不可. 插入排序与选择排序的共同点 外循环均是标识当前数组中左侧有序的元素的个数 内循环均是使用右侧的元素,与左侧有序的元素进行比较 API 设计和选择排序一样,插入排序依旧使用通用的排序 API.原因: 数组的排序,无非是访问数组,比较元素,交换元素.insert.hpp 1234567891011121314151617181920212223/// Created by yi on 2020/4/14.//#ifndef PART2_INSERT_HPP#define PART2_INSERT_HPP#include &lt;iostream&gt;template&lt;typename T&gt;class insert &#123;public: static void sort(T arr[], const size_t &amp;&amp;size); static bool isSorted(T arr[]); static bool less(T v, T w); static void exch(T arr[], const int &amp;i, const int &amp;j); void show(T arr[], const size_t &amp;&amp;size);&#125;; 实现insert.hpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * 进行插入排序 * @tparam T 传入排序的数组的元素的类型 * @param arr 待排序数组的首地址 * @param size 待排序数组的大小 */template&lt;typename T&gt;void insert&lt;T&gt;::sort(T *arr, const size_t &amp;&amp;size) &#123; for (int i = 1; i &lt; size; ++i) &#123; for (int j = i; j &gt; 0 &amp;&amp; less(*(arr + j), *(arr + (j - 1))); --j) &#123; exch(arr, j, j - 1); &#125; &#125;&#125;/** * 判断数组是否有序,PS: 忽略了不定数量相等元素的情况 * @tparam T 判断是否有序的数组中的元素的类型 * @param arr 判断是否有序的数组的首地址 * @return true：有序，false：无序 */template&lt;typename T&gt;bool insert&lt;T&gt;::isSorted(T *arr) &#123; T *temp = arr; return (*arr &lt; *(++temp));&#125;/** * 判断给定的两个元素的大小 * @tparam T 元素的类型 * @param v 待比较的元素 * @param w 待比较的元素 * @return true：v 小于 w，false： v 大于 w */template&lt;typename T&gt;bool insert&lt;T&gt;::less(T v, T w) &#123; return v &lt; w;&#125;/** * 交换给定的两个元素 * @tparam T 数组中元素的类型 * @param arr 数组的首地址 * @param i 用于交换的元素的索引 * @param j 用于交换的元素的索引 */template&lt;typename T&gt;void insert&lt;T&gt;::exch(T *arr, const int &amp;i, const int &amp;j) &#123; *(arr + i) ^= *(arr + j); *(arr + j) ^= *(arr + i); *(arr + i) ^= *(arr + j);&#125;/** * 遍历并打印给定的数组 * @tparam T 用来遍历的数组中的元素的类型 * @param arr 数组的首地址 * @param size 数组中元素的数量 */template&lt;typename T&gt;void insert&lt;T&gt;::show(T *arr, const size_t &amp;&amp;size) &#123; for (int i = 0; i &lt; size; ++i) &#123; std::cout &lt;&lt; *(arr + i); std::cout &lt;&lt; " "; &#125; std::cout &lt;&lt; std::endl;&#125;#endif //PART2_INSERT_HPP PS: 要注意内层循环.内存循环是逆序访问当前有序的数组,然后用当前选中的元素,去与当前有序的数组内进行选择排序 测试123456789101112#include "insert.hpp"using namespace std;int main() &#123; int arr[4] = &#123;2, 3, 1, 4&#125;; auto *test = new insert&lt;int&gt;; insert&lt;int&gt;::sort(arr, 4); test-&gt;show(arr, 4); if (insert&lt;int&gt;::isSorted(arr))&#123; cout&lt;&lt;"true"&lt;&lt;endl; &#125;&#125; 123结果:1 2 3 4true 总结在排序的时候,逆向利用了插入排序.]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>插入排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择排序]]></title>
    <url>%2F2020%2F04%2F13%2F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[选择排序选择排序是一种非常常见的排序算法.他具有一个别的算法都不具备的优点特性:移动元素的次数最少,一共交换了 N 次.(用来排序的数组的大小)同时,他有也一个特有的缺点特性:无法利用输入元素的初试状态 即使输入的元素有序,他依然会从头到位一步不少的执行一遍自己的排序步骤. API 设计API 设计为,所有的排序算法通用的接口.从中可以抽象出排序算法的基本操作: 比较元素大小,交换元素. 进行排序 判断给出的数组是否有序 判断元素的大小 交换给定的两个元素 遍历输出给定的数组 select.hpp 1234567891011121314151617181920212223//// Created by yi on 2020/4/11.//#ifndef PART2_SELECT_H#define PART2_SELECT_H#include &lt;iostream&gt;template&lt;typename T&gt;class select &#123;public: static void sort(T arr[], const size_t &amp;&amp;size); static bool isSorted(T arr[], const size_t &amp;&amp;size); static bool less(T v, T w); static void exch(T arr[], const int&amp; i, const int&amp; j); void show(T arr[], const size_t &amp;&amp;size);&#125;; 实现select.hpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * 进行选择排序 * @tparam T 传入排序的数组的元素的类型 * @param arr 待排序数组的首地址 * @param size 待排序数组的大小 */template&lt;typename T&gt;void select&lt;T&gt;::sort(T *arr, const size_t &amp;&amp;size) &#123; for (int i = 0; i &lt; size - 1; ++i) &#123; for (int j = i + 1; j &lt; size; ++j) &#123; if (less(*(arr + j), *(arr + i))) &#123; exch(arr, i, j); &#125; &#125; &#125;&#125;/** * 判断数组是否有序,PS: 忽略了不定数量相等元素的情况 * @tparam T 判断是否有序的数组中的元素的类型 * @param arr 判断是否有序的数组的首地址 * @return true：有序，false：无序 */template&lt;typename T&gt;bool select&lt;T&gt;::isSorted(T *arr, const size_t &amp;&amp;size) &#123; T *temp = arr; /*数组中的所有元素都相等*/ if (*arr == *(temp + size)) &#123; return true; &#125; return *arr &lt; (*(++temp));&#125;/** * 判断给定的两个元素的大小 * @tparam T 元素的类型 * @param v 待比较的元素 * @param w 待比较的元素 * @return true：v 小于 w，false： v 大于 w */template&lt;typename T&gt;bool select&lt;T&gt;::less(T v, T w) &#123; return v &lt; w;&#125;/** * 交换给定的两个元素 * @tparam T 数组中元素的类型 * @param arr 数组的首地址 * @param i 用于交换的元素的索引 * @param j 用于交换的元素的索引 */template&lt;typename T&gt;void select&lt;T&gt;::exch(T *arr, const int&amp; i, const int&amp; j) &#123; *(arr + i) ^= *(arr + j); *(arr + j) ^= *(arr + i); *(arr + i) ^= *(arr + j);&#125;/** * 遍历并打印给定的数组 * @tparam T 用来遍历的数组中的元素的类型 * @param arr 数组的首地址 * @param size 数组中元素的数量 */template&lt;typename T&gt;void select&lt;T&gt;::show(T *arr, const size_t &amp;&amp;size) &#123; for (int i = 0; i &lt; size; ++i) &#123; std::cout &lt;&lt; *arr + i; std::cout &lt;&lt; " "; &#125; std::cout &lt;&lt; std::endl;&#125;#endif //PART2_SELECT_H PS:利用位运算交换元素的理解: 123456假设 a = 1;b = 0;a ^= b --&gt; 0001 ^= 0000 --&gt; 0001 用 a 保存 两数字二进制不等的地方b ^= a --&gt; 0000 ^= 0001 --&gt; 0001 用 b 取出 aa ^= b --&gt; 0001 ^= 0001 --&gt; 0000 用 a 取出 b利用了 门电路中的 异或门 的特性 测试123456789101112131415161718#include "select.hpp"using namespace std;int main() &#123; int arr[4] = &#123;2, 3, 1, 4&#125;; auto *test = new select&lt;int&gt;; select&lt;int&gt;::sort(arr, 4); test-&gt;show(arr, 4); if (select&lt;int&gt;::isSorted(arr, 4)) &#123; cout &lt;&lt; "有序" &lt;&lt; endl; &#125; int same[3] = &#123;1, 1, 1&#125;; if (select&lt;int&gt;::isSorted(same,3))&#123; cout &lt;&lt; "有序" &lt;&lt; endl; &#125;&#125; 1234结果:1 2 3 4有序有序 总结选择排序的实现,利用了快慢指针的思想.快慢指针的变种可以是多种多样的,比如:给定两个数组,通过遍历来找出数组中最小、最大的元素 选择排序的外循环: 慢指针 选择排序的内循环: 快指针 通过快慢指针的终止状态,可以实现排序,查找最大最小元素. 升序: 快指针的终止状态: 当前无序数组中的最大元素 降序: 快指针的终止撞停: 当前无序数组中的最小元素 升序: 慢指针的终止状态: 当前数组为升序 降序: 慢指针的终止撞动态: 当前数组为降序]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>选择排序</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单向循环链接及其应用]]></title>
    <url>%2F2020%2F04%2F05%2F%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E6%8E%A5%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[单向循环链表在解决圆桌问题时,单向循环链表是一种非常合适的数据结构.因为,他可以循环计数. 节点设计节点需要两个元素: 数据域: 存放数据 指针域: 存放下一个节点的地址 链表为空时,头节点指向自己 1.2 均为私有,防止数据的意外修改 添加链表类为友元,实现链表对节点的操作 节点的实现node.hpp 123456789101112131415161718192021222324252627282930//// Created by yi on 2020/4/6.//#ifndef PART1_NODE_HPP#define PART1_NODE_HPPtemplate &lt;typename T&gt; class circleList;template&lt;typename T&gt;class Node&#123;public: friend class circleList&lt;T&gt;; Node(): m_pnext(nullptr)&#123; &#125; explicit Node(const T data, Node&lt;T&gt;* m_pnext= nullptr): m_data(data), m_pnext(m_pnext)&#123; &#125; ~Node()&#123; m_pnext= nullptr; &#125;private: T m_data; Node&lt;T&gt;* m_pnext;&#125;;#endif //PART1_NODE_HPP 设计思路有参构造函数,可以将数据域用 引用 实现.这儿没采用引用的原因,方便使用字面量来赋值. 节点的构造函数,采用了初始化列表,提高类的实例华效率. explicit 关键字,则说明了该函数只能用于构造函数. 链表 API 封装API 封装的思路: 创建头节点 为链表添加数据 获取链表的长度 判断链表是否为空 根据索引获取对应节点的值 根据索引移除对应位置节点 清空链表 链表实现circleList.hpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145//// Created by yi on 2020/4/6.//#ifndef PART1_CIRCLELIST_HPP#define PART1_CIRCLELIST_HPP#include &lt;cstdio&gt;#include &lt;iostream&gt;#include "node.hpp"/** * * @tparam T 链表中节点存放的元素的类型 * @emptyList 清空链表 * @size 获取链表的长度 * @add 添加元素 * @find 找到第 n 个元素并返回（指针，修改会影响到链表中的元素） * @del 删除第 n 个元素 * @get 获取第 n 个元素（拷贝，修改该变量不会影响链表中的元素） * @print 遍历打印当前链表 */template&lt;typename T&gt;class circleList &#123;public: explicit circleList(T data) &#123; m_head = new Node&lt;T&gt;(data); m_head-&gt;m_data = data; m_head-&gt;m_pnext = m_head; &#125; ~circleList() &#123; delete m_head; &#125;public: virtual size_t size(); bool insert(T data, int index = 0);// data,index 不使用引用的原因，避免使用的时候传入了字面量，导致程序崩溃。 T find(int n); bool del(int n); void emptyList();public: Node&lt;T&gt; *m_head;&#125;;/** * 不返回指针的原因： 1. 返回指针在该处断码执行完毕后，在栈上的元素会被释放，导致指针空悬,所以返回变量的拷贝 * 2. Node 中的数据域为私有，需要返回拷贝，可以让外界取得所需的值，又不影响到原始的链表中的数据 * @tparam T * @param n * @return */template&lt;typename T&gt;T circleList&lt;T&gt;::find(int n) &#123; if (0 &gt; n || n &gt; size()) &#123; exit(1); &#125; Node&lt;T&gt; *tem = m_head; for (int i = 0; i &lt; n; ++i) &#123; tem = tem-&gt;m_pnext; &#125; return tem-&gt;m_data;&#125;template&lt;typename T&gt;bool circleList&lt;T&gt;::del(int n) &#123; /* n 不能等于 0 ，留下头节点备用*/ if (0 &gt;= n || n &gt; size()) &#123; return false; &#125; Node&lt;T&gt; *tem = m_head; Node&lt;T&gt; *delTem = nullptr; for (int i = 0; i &lt; n - 1; ++i) &#123; tem = tem-&gt;m_pnext; &#125; delTem = tem-&gt;m_pnext; tem-&gt;m_pnext = delTem-&gt;m_pnext; delete delTem; return true;&#125;template&lt;typename T&gt;void circleList&lt;T&gt;::emptyList() &#123; Node&lt;T&gt; *delNode = nullptr; Node&lt;T&gt; *curNode = m_head-&gt;m_pnext; while (curNode-&gt;m_pnext != m_head) &#123; delNode = curNode; curNode = curNode-&gt;m_pnext; delete delNode; &#125; m_head-&gt;m_pnext = m_head;&#125;/** * @tparam T * @param data * @param index * @return */template&lt;typename T&gt;bool circleList&lt;T&gt;::insert(T data, int index) &#123; if (0 &gt; index || index &gt; size()) &#123; // 越界 return false; &#125; Node&lt;T&gt; *tem = m_head; auto *newNode = new Node&lt;T&gt;(data); for (int i = 0; i &lt; index; ++i) &#123; tem = tem-&gt;m_pnext; &#125; newNode-&gt;m_pnext = tem-&gt;m_pnext; tem-&gt;m_pnext = newNode; return true;&#125;template&lt;typename T&gt;size_t circleList&lt;T&gt;::size() &#123; /* 只有头节点的情况 */ size_t size = 0; if (m_head-&gt;m_pnext == m_head) &#123; return ++size; &#125; Node&lt;T&gt; *tem = m_head-&gt;m_pnext; while (tem != m_head) &#123; tem = tem-&gt;m_pnext; ++size; &#125; return size;&#125;#endif //PART1_CIRCLELIST_HPP 设计思路 当链表数据量足够大时,可以采用添加一个 size_t 类型的成员变量,m_size 来存储链表的长度.只需要在每次 添加, 删除 数据时,对 m_size 进行更新即可.(推荐使用) 链表添加节点时,可以采用引用传递.上述代码未使用引用传递的原因: 为了方便使用字面量进行赋值. 防止链表二次释放,(链表调用 emptyList(),清空一次链表,调用析构函数时再次调用 emptyList()),需要在析构函数中添加链表的长度判断. 调用 emptyList(),清空链表时,在清空了所有元素后,需要对头节点,进行再次初始化(即,头节点的指针域,指针自身).防止后序操作出现问题. 插入元素时的边界问题: 可采用 size_t 类型的索引,来规避部分左边界判断. 插入的索引,不可大于当前链表的长度. 链表插入,默认是从头节点下一个开始进行插入的. 获取链表元素时的边界问题: 可采用 size_t 类型的索引,来规避部分左边界判断. 获取元素的索引,不可大于当前链表的长度. 删除元素时的边界问题: 传入的元素索引不能为 0,规避删除头节点的风险 传入的元素索引,不能大于链表的长度 测试main.cpp 1234567891011121314151617181920212223 using namespace std;int main(int argc, char *argv[]) &#123; auto* myList=new circleList&lt;int&gt;(0); for (int i = 0; i &lt; 10; ++i) &#123; myList-&gt;insert(i*2,i); &#125; cout&lt;&lt;myList-&gt;size()&lt;&lt;endl; for (int j = 0; j &lt; 5; ++j) &#123; myList-&gt;del(j+1); &#125; cout&lt;&lt;myList-&gt;size()&lt;&lt;endl; // 输出 5 myList-&gt;emptyList(); cout&lt;&lt;myList-&gt;size()&lt;&lt;endl; // 输出 1 ，因为只剩下头节点 for (int i = 0; i &lt; 10; ++i) &#123; myList-&gt;insert(i*2,i); &#125; cout&lt;&lt;myList-&gt;size()&lt;&lt;endl; // 输出 10 auto tem=new circleList&lt;int&gt;(1); cout&lt;&lt;tem-&gt;size()&lt;&lt;endl;&#125; 用单向循环链表实现队列这个很简单,只有一个注意点,这个注意点还是自己强行加上的.就是: 在 circleList 中将 size() 声明为虚函数,然后在 queue 中继承时,重写该虚函数即可. API 设计 创建队列(先调用父类的构造函数,用头节点标识:空队列) 将元素入队 移除元素 将元素出队 获取队列的长度 清空队列 实现queue.hpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//// Created by yi on 2020/4/8.//#ifndef PART1_QUEUEWITHCIRCLELIST_HPP#define PART1_QUEUEWITHCIRCLELIST_HPP#include "circleList.hpp"template&lt;typename T&gt;class queueWithcircleList : public circleList&lt;T&gt;&#123;public: queueWithcircleList(); explicit queueWithcircleList(T data) : m_data(data) &#123; &#125; bool push(T data); bool pop(); T top(); void emptyQueue(); size_t size(); ~queueWithcircleList() = default;private: T m_data;&#125;;template&lt;typename T&gt;queueWithcircleList&lt;T&gt;::queueWithcircleList() &#123;&#125;template&lt;typename T&gt;bool queueWithcircleList&lt;T&gt;::push(T data) &#123; int size = circleList&lt;T&gt;::size(); return circleList&lt;T&gt;::insert(data, size + 1);&#125;template&lt;typename T&gt;bool queueWithcircleList&lt;T&gt;::pop() &#123; return circleList&lt;T&gt;::del(1);&#125;template&lt;typename T&gt;T queueWithcircleList&lt;T&gt;::top() &#123; return circleList&lt;T&gt;::find(1);&#125;template&lt;typename T&gt;size_t queueWithcircleList&lt;T&gt;::size() &#123; return circleList&lt;T&gt;::size();&#125;template&lt;typename T&gt;void queueWithcircleList&lt;T&gt;::emptyQueue() &#123; circleList&lt;T&gt;::emptyList();&#125;#endif //PART1_QUEUEWITHCIRCLELIST_HPP 测试123456789101112int main(int argc, char *argv[]) &#123; auto*p=new queueWithcircleList&lt;int&gt;(); for (int i = 0; i &lt; 10; ++i) &#123; p-&gt;push(i); &#125; cout&lt;&lt;p-&gt;size()&lt;&lt;endl; cout&lt;&lt;p-&gt;top()&lt;&lt;endl; p-&gt;pop(); cout&lt;&lt;p-&gt;top()&lt;&lt;endl; p-&gt;emptyQueue(); return 0;&#125; Josephus尽量不要使用带头节点的循环链表来处理 Josephus 问题,否则的话会遇到相当多的关于循环时头节点的问题.大大增加逻辑的复杂性,造成程序的可读性严重下降. 用 C 语言来处理会更简单.不推荐用上面封装的 C++ 代码来进行处理.因为上面的 C++ 代码,无法手动控制链表.只能用封装好的 API 来进行控制.如果强行的控制的话,会有一个 bug,就是循环链表中的头节点更换后,处理尾节点的指向,无法处理(当然也不是无法处理,处理后就像是强行用 C 来控制 C++,没有美感) 所以直接用 C 代码来进行处理.要求: Josephus问题。在这个古老的问题中,N 个身陷绝境的人一致同意通过以下方式减少生存人数。他们围坐成一圈(位置记为 0 到 N-1)并从第一个人开始报数,报到 M 的人会被杀死, 直到最后一个人留下来。传说中 Josephus 找到了不会被杀死的位置。编写一个 Queue的用例Josephus, 从命令行接受 N 和 M 并打印出人们被杀死的顺序 (这也将显示 Josephus 在圈中的位置) 。 思路 建立循环链表 分别取出待删除元素和待删除元素的前一个元素 移除元素 更新下次计数开始的节点PS: 需要注意的是 2 步.待删除节点和待删除节点的前一个节点是同时取得的. 实现Josephus 12345678910111213141516171819202122232425262728293031323334353637383940414243typedef struct node &#123; int data; struct node *pnext;&#125; Node1;void JOSEPHUS(int size, int killer) &#123; Node1 *tail, *head; head = NULL; // 建立循环链表 for (int i = 0; i &lt; size; i++) &#123; Node1 *newNode = (Node1 *) malloc(sizeof(Node1)); newNode-&gt;data = i; newNode-&gt;pnext = NULL; if (NULL == head) &#123; /* 链表中只有一个节点的时候，头尾节点指定同一个节点 */ newNode-&gt;pnext = newNode; head = newNode; tail = newNode; &#125; else &#123; tail-&gt;pnext = newNode; newNode-&gt;pnext = head; tail = newNode; &#125; &#125; Node1 *kill = head; Node1 *temp = NULL; /*将报到指定数字的人，移除队列*/ while (kill-&gt;pnext != kill) &#123; for (int k = 0; k &lt; killer - 1; k++) &#123; temp = kill; kill = kill-&gt;pnext; &#125; temp-&gt;pnext = kill-&gt;pnext; /*将出队的元素的前一个元素，指向出队元素的下一个元素*/ temp=kill-&gt;pnext; /* 更新循环开始的地方 */ printf("Delete number: %d\n", kill-&gt;data); // 打印所要删除结点的数据 free(kill); // 删除结点，从内存释放该结点占用的内存空间 kill = temp; &#125; printf("The last one is No.%d\n", kill-&gt;data);&#125;#endif //PART1_JOSEPHUS_H 测试12345678int main(int argc, char *argv[]) &#123; int size,remove; cin &gt;&gt; size; cin.get(); cin&gt;&gt;remove; JOSEPHUS(size,remove); return 0;&#125; case: 127 21 3 5 0 4 2 6]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈的简单使用总结]]></title>
    <url>%2F2020%2F04%2F04%2F%E6%A0%88%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[栈结构的常见使用得益于栈结构的简单性，栈是很多高级算法的基础。有着丰富的应用。 常见的使用： 0x01. 队列的逆序输出 0x02，求数值的二进制运算 0x03. dijkstra 算法解决四则运算问题 0x04. dijkstra 算法解决括号匹配问题 0x05. 数学表达式的中序变后序转化 队列的逆序输出队列的逆序输出，使用栈来实现是最简单，最容易让人理解的。 思路队列：FIFO栈：FILO 0x01. 将队列中的元素依次出队，并依次压入栈中。 0x02. 栈中的元素依次弹栈 完美的结合利用了，这两种简单的数据结构的特性。进而实现了队列的逆序输出 实现太简单了，只写伪代码： 123456queue&lt;type&gt; que;stack&lt;type&gt; sta;while(!que.empty())&#123; sta.push(que.top()); que.deque();&#125; 上述伪代码，利用栈实现了队列的逆序。 求数值的二进制运算也是非常基础的栈的应用,只是思路不易让人想到. 是收到数学计算数值的二进制,得到的启发. 思路 0x01. 对数值 A 进行求解二进制. 0x02. 对 A 进行模 2 运算.并将结果入栈. 0x03. A = A / 2 0x04. 判断出口条件 0x05. 完成 PS: 思路看起来不容易理解,可以试着随便做一个数值的二进制转化,看下计算过程.能加深对 0x02, 0x03 的理解. 实现过于简单,放伪代码 123456789101112stack&lt;int&gt; sta;int num = 10;while(num&gt;0)&#123; sta.push(num%2); num /= 2;&#125;while(!sta.empty())&#123; cout&lt;&lt;sta.top(); sta.pop();&#125;cout&lt;&lt;endl; dijkstra 算法解决四则运算利用 dijkstra 算法来处理四则运算，是栈的高级应用的基础。 思路 0x01. 创建两个用于存放操作符和操作数的栈 0x02. 将表达式的 操作符 ,操作数 分别压入对应栈中 操作符入栈时,忽略左括号 操作符入栈时,遇到右括号停止入栈(或,在 0x04 完成后,再入栈) 0x03. 从 操作符栈 中取出操作符,并从 操作数栈 中取出操作符所需数目的操作数 0x04. 将计算结果压入 操作数栈 中,并弹出 操作符栈 中的操作符,继续 0x02-0x04 0x05. 得到结果 实现dijkstra.h 12345678910111213141516#ifndef LEARNA_DIJKSTRA_H#define LEARNA_DIJKSTRA_H#include &lt;string&gt;class dijkstra &#123;public: explicit dijkstra(std::string input); ~dijkstra(); int result();private: std::string m_origin_string;&#125;;#endif //LEARNA_DIJKSTRA_H dijkstra.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;utility&gt;//// Created by _yi on 2020/1/4.//#include "dijkstra.h"#include &lt;stack&gt;#include &lt;iostream&gt;dijkstra::dijkstra(std::string input) &#123; m_origin_string = std::move(input);&#125;dijkstra::~dijkstra() = default;int dijkstra::result() &#123; // 获取一个含运算符和操作数的字符串 std::stack&lt;char&gt; operator_stack; std::stack&lt;int&gt; alp_stack; // 忽略左括号 for (auto s :m_origin_string) &#123; /** 将运算符压入运算符栈**/ if ('(' == s) &#123; continue; &#125; else if ('+' == s) &#123; operator_stack.push(s); &#125; else if ('-' == s) &#123; operator_stack.push(s); &#125; else if ('*' == s) &#123; operator_stack.push(s); &#125; else if ('/' == s) &#123; operator_stack.push(s); &#125; /** * 从 operator_stack 中取出运算符和运算符所需数量的操作数 * 计算完毕后，从 alp_stack 中移除已经使用过的操作数 * 并将计算后的结果压入 alp_stack **/ else if (')' == s) &#123; char operaton_char = operator_stack.top(); operator_stack.pop(); int num = alp_stack.top(); alp_stack.pop(); if ('+' == operaton_char) &#123; num = num + alp_stack.top(); alp_stack.pop(); &#125; else if ('-' == operaton_char) &#123; num = num - alp_stack.top(); alp_stack.pop(); &#125; else if ('*' == operaton_char) &#123; num = num * alp_stack.top(); alp_stack.pop(); &#125; else if ('/' == operaton_char) &#123; num = num / alp_stack.top(); alp_stack.pop(); &#125; alp_stack.push(num); &#125; /** 将数字压入alp_stack**/ else &#123; alp_stack.push(static_cast&lt;int&gt;(s) - 48); &#125; &#125; return alp_stack.top();&#125; dijkstra 算法解决括号匹配问题该场景有两个复杂程度不可同日而语的场景: 简单的: 判断括号是否匹配 复杂的: 将缺失的括号,按照规则补全 注意 复杂的来题目自算法第四版: 1.3.9 习题 思路 简单的: 将表达的操作符依次入栈,直到遇到第一个右括号 判断操作符栈,栈顶元素是否与右括号匹配.匹配: 正确,继续执行,不匹配,错误.跳出执行 复杂的: 0x01. 创建两个栈,一个存放 操作符,一个存放操作数 0x02. 操作符入栈时以 右括号 为哨兵. 0x03. 遇到哨兵,则依次取出操作符,和操作符所需的操作数 0x04. 组合表达式(添加左右括号) 0x05. 将表达式操作数栈 0x06. 0x02 - 0x05,直到达到循环出口条件 实现简单的: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* * 忽略了异常的状态：输入为非法字符 * 思路：将标准输入中的所有左括号放入栈中，然后读取到右括号后从栈顶取出元素进行比较 * 1 异常：左括号的数量比右括号数量多 * 2 异常：右括号的数量比左括号数量多 */bool parentheses() &#123; char input; bool result = false; std::stack&lt;char&gt; parentheses; while (std::cin &gt;&gt; input) &#123; if (input == '(' || input == '[' || input == '&#123;') &#123; parentheses.push(input); &#125; else &#123; // 符号匹配处理 if (input == ')') &#123; if (parentheses.top() != '(') &#123; return false; &#125; result = true; &#125; else if (input == ']') &#123; if (parentheses.top() != '[') &#123; return false; &#125; result = true; &#125; else if (input == '&#125;') &#123; if (parentheses.top() != '&#123;') &#123; return false; &#125; result = true; &#125; // 出栈及异常处理 if (!parentheses.empty()) &#123; parentheses.pop(); &#125; else &#123; // 左括号比右括号数量多的情况 return false; &#125; &#125; &#125; // 异常处理 if (!parentheses.empty()) &#123; // 右括号比左括号数量多的情况 return false; &#125; return result;&#125; case1: 正确的 12echo &quot;&#123;[()]&#125;“ | ./main输出: 1 case2: 错误的 12echo &quot;(()&quot; | ./main输出: 0 复杂的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* * 思路：由于栈的出栈顺序是逆序的，而左右括号又是自己添加的。所以要逆序添加括号。 * 采用 dijkstra 算法。由于 C++ 字符转 string 有很多不便，故而添加了个存放结果的栈 * 1 操作符入栈 * 2 操作数入栈 * 3 添加 + - 运算表达式的括号，组合表达式。在 + - 表达式组合完成后，操作符栈内只余下 * / 等运算 * 4 从 result 栈（string）中取出组合好的 + - 表达式，进行复杂表达式的构建 * 5 逆序输出结果 */void autoParent() &#123; std::stack&lt;char&gt; vals; std::stack&lt;std::string&gt; result; std::stack&lt;char&gt; oprs; std::string exp; char input; char leftNum; char rightNum; while (std::cin &gt;&gt; input) &#123; // 操作符入栈 std::string temExp; if (input &lt; '0' &amp;&amp; input != ')') &#123; oprs.push(input); &#125; else if (input &gt;= '0') &#123; // 操作数入栈 vals.push(input); &#125; else if (input == ')') &#123; // 操作符，操作数出栈，拼接新字符串,并入操作数栈 if (!vals.empty()) &#123; rightNum = vals.top(); vals.pop(); leftNum = vals.top(); vals.pop(); temExp.push_back(')'); temExp.push_back(rightNum); temExp.push_back(oprs.top()); temExp.push_back(leftNum); temExp.push_back('('); oprs.pop(); result.push(temExp); &#125; else &#123; temExp.push_back(')'); temExp+=result.top(); result.pop(); temExp+=oprs.top(); oprs.pop(); temExp+=result.top(); result.pop(); temExp.push_back('('); result.push(temExp); &#125; &#125; &#125; exp=result.top(); std::reverse(std::begin(exp), std::end(exp)); std::cout&lt;&lt;exp&lt;&lt;std::endl;&#125; case: 12echo &quot;1+2)*3-4)*5-6)))&quot; | ./main输出: ((1+2)*((3-4)*(5-6)))]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VPS 网络防护]]></title>
    <url>%2F2020%2F03%2F22%2FVPS-%E7%BD%91%E7%BB%9C%E9%98%B2%E6%8A%A4%2F</url>
    <content type="text"><![CDATA[VPS 安全防护的原因VPS 因为具有公网 IP，且大多数私人用的 VPS 没有很好的管理习惯。所以有很多的人，在网上对暴露在公网上的 VPS 进行扫描，暴力 SSH 破解。进而实现包括但不限于：以 VPS 作为肉鸡、单纯的破坏 VPS、窃取 VPS 中的信息、挖矿 等目的。 为了更好的保护 VPS 的资源，避免 VPS 被别人用作其他用途，对 VPS 进行一定程度的安全防护设置是非常必要的。 VPS 防护的手段VPS 防护的手段常见方式不外乎两种：0x00. 设置防火墙 过滤恶意流量，防止服务器被爆破。 0x01. 私钥登陆 更改 SSH 默认端口，防止 SSH 暴力破解 设置私钥登陆，并禁止使用密码和 root 账号登陆 设置防火墙PS: 下面以 Debian 系列进行说明。设置防火墙屏蔽不必要的端口，可以屏蔽绝大多数的恶意流量。大大的加强 VPS 的安全性。 安装配置 ufw 防火墙工具0x00. su 0x01. sudo apt install ufw 0x02. systemctl enable ufw 命令解释：开启 ufw 的自动启动。这样不用在每次开关机后，再次手动重启 ufw 的服务。 0x03. systemctl start ufw 命令解释：开启 ufw 0x04. ufw status 命令解释：查看当前 ufw 的状态 0x05. ufw allow ssh 命令解释：允许 ssh 协议流量通过防火墙，并开放默认的 ssh 端口（22） 0x06. ufw status 命令解释：查看 ssh 规则是否添加成功。 PS：ufw 有很多设置方式：比如可以直接指定要开发的端口 ufw allow 端口号，可以指定协议等。详细请参考 man ufw 小结现在防火墙已经打开，所有访问非 22 端口的流量，或则以非 ssh 协议访问 22 端口的流量，均会被防火墙自动拦截。这样就可以过滤绝大部分的恶意流量了。但是还是无法方式 SSH 暴力破解，这一让人头疼的问题。防止 SSH 暴力破解的方案，放在下面的 证书登陆中了。 私钥登陆原理：简单来说就是一句话：非对称加密的密钥具有一对一的特性。一个公钥，加密后的内容，只能被其对应的私钥进行解密。而我们在 VPS 上利用证书登陆，就是利用了这一特性。 具体使用分为 3 部分： 1. 证书的生成 2. authorized_keys 设置 3. 相关文件的权限设置 私钥的生成注意：VPS 新建用户不推荐加入 sudo 组中，以便做好用户的权限隔离。以下均在要生成密钥的用户下执行。即：要在 A 生成密钥，请切换到 A 用户再去执行下面的命令。 0x00. mkdir ~/.ssh 命令解释：在自己的家目录下，新建名为 .ssh 的目录。 0x01. 执行 ssh-keygen -t rsa -b 4096 -C &quot;注释信息，便于理解密钥用处，一般为邮件地址 - 命令解释： script12usage: ssh-keygen [-q] [-b bits] [-t dsa | ecdsa | ed25519 | rsa] [-N new_passphrase] [-C comment] [-f output_keyfile] 通过 ssh 的帮助文档中的第一、二行，我们可以清楚的看到 ssh-keygen 常用的参数的含义： -t 选项：生成的密钥的类型 -b 选项：生成的密钥的长度单位为 bit -C 选项：生成的密钥的注释信息0x02. Enter file in which to save the key: 选择密钥的存放位置，一般默认即可。可以通过绝对、相对路径来指定。 0x03. Enter passphrase (empty for no passphrase): 如果不需要利用密码对生成的密钥进行加密，回车即可。 PS：如果输入了密码，每次在用密钥进行登陆时，也会要求输入密码，用以解锁加密的密钥。 0x04. 下面就是密钥的指纹密码了。可以忽略。 0x05. touch ~/.ssh/authorized_keys &amp;&amp; cat id_rsa.pub &gt;&gt; authoried_keys 命令解释：在 .ssh 目录下新建 authorized_keys 的文件，并将 id_rsa.pub (上面生成的密钥中的公钥) 添加 authorized_keys 文件 的末行后。0x06. chomod 700 .ssh &amp;&amp; chmod 600 .ssh/authorized_keys 命令解释：改变 .ssh 和 authorized_keys 的权限为：700 属主可读写运行，属组和其他用户无权限，600 属主可读写，属组和其他用户无权限 PS: 这一步不是必须的，但是推荐这么做。可以避免一些权限的问题。 0x07. 保存公钥对应的私钥到本地。并在 authorized_keys 文件中，公钥信息的上面以 # 开头添加注释信息。推荐：注释信息为对应使用该密钥登陆的用户名 0x08. 在不同的用户中重复执行 0x00-0x04 和 0x06 步骤。0x05 步骤需要部分改变 0x09. 改变后的 0x05 步骤：同样的先执行 0x05 的命令。然后追加 cat /home/othername/.ssh/authorized_keys &gt;&gt; .ssh/authorized_keys 命令解释：将 othername 换为你的其他有密钥的用户的用户名，将其他用户的 authorized_keys 的内容追加到当前的 authorized_keys 中。 0x0A. 还有其他用户参考上面同理。 设置允许私钥登陆并进行 SSH 配置0x00. su0x01. vi /etc/ssh/sshd_config 找到 AuthorizedKeysFile .ssh/authorized_keys .ssh/authorized_keys2 将前面的 # 号去掉。PS: 如果没解除该句的注释，那么只能用最后一次生成的密钥来登陆最后一个生成密钥的用户。或则，所有用户利用相同的密钥来进行登陆。无法实现不同用户使用不同的密钥来进行登陆。原因：参考 ssh 认证中，会从 authorized_keys 中读取存放的公钥信息。来对进行登陆的用户的私钥进行检查。即使你不去设置 authorized_keys 文件，系统仍然会默认在你第一次用密钥登陆时，在该用户的 .ssh 目录下，生成 authorized_keys 文件。 0x02. systemctl restart sshd 重启 SSH 服务。 0x03. 测试所有用户用密钥登陆: ssh -i 证书位置 username@ip 成功后进行下一步，不成功，请确认是否正确完成了上面的所有操作。 如果不行，可以用密码登陆 root 用户从头再来。 0x04. 执行 0x01 找到 Port 22 更改为 Port 你想用的端口 推荐大于 1024,因为 1024 及以下的端口 Linux 系统作为保留。一定要小于 65535。 执行 0x02 切换到 root 用户执行 ufw allow 你想用的端口号,否则在断开 SSH 连接后，你就登陆不上服务器了。 0x04. 测试所有用户连接: ssh -p 0x04指定的端口 -i 证书位置 username@ip 成功后进行下一步，不成功，请确认是否正确完成了上面的所有操作。 如果不行，可以用密码登陆 root 用户从头再来。 0x05. 执行 0x01 找到 PasswordAuthentication yes 并将 yes 改为 no。 执行 0x02 0x06. 测试所有用户连接: ssh -p 0x04指定的端口 username@ip 拒绝密码登陆，成功后进行下一步，不成功，请确认是否正确完成了上面的所有操作。 如果报错 Permission denied 则证明成功可以使用 0x04 进行登陆。 如果不行，请用密钥登陆 root 用户从头再来。 0x07. 执行 0x01 找到 PermitRootLogin yes 改为 no 禁止 root 用户登录。在重启 ssh 之前，请将你的 root 密码更改为简单容易记的。以后用密钥登陆服务器，su 的时候要用。 执行 0x02 原因：防止 SSH 端口被扫描到，别人进行 root 用户包跑（虽然，上面禁止了密码登陆，但是怕有的人觉得禁止密码登陆麻烦，还是留下这一步）。 0x08. 测试 root 用户连接 ssh -p 0x04指定的端口 root@ip 如果报错 Permission denied 则证明成功。可以使用 0x04 登陆。 小结上面的设置从 SSH 层面做了以下几件事： 更改默认的 SSH 端口，防止暴力 SSH 破解。 更改了 SSH 登陆的方式：从密码登陆 -&gt; 只允许密钥登陆,防止了密码的泄露。 更改了 SSH 登陆的用户限制，只允许非 root 用户登陆,防止了中间人攻击。 而且新建的用户均无 sudo 的权限，这样 VPS 就具有了三层防护。基本可以防止 99% 的恶意攻击了。另外，不方便更改 SSH 端口的用户，可以参考使用 fail2ban 工具。（有时间的话，单独写一篇教程） 总结VPS 安全防护的第一步：权限的隔离：包括用户权限——普通用户均不在 sudo 组中，文件的权限：登陆的密钥只允许用户的属主使用,防止了单个用户破解，进而导致系统全部暴漏。VPS 安全防护的第二步：关闭不必要的端口，尽可能减少自己在公网上暴露的信息。即设置防火墙允许自己想要使用的端口，其余端口全部拒绝。VPS 安全防护的第三步：更改 SSH 配置。以达到只能用非 root 用户，只能利用密钥从指定的端口登陆。最大限度的降低登陆用户遭破解，对系统造成的影响。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>SSH</tag>
        <tag>密钥登陆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛型链式队列的实现]]></title>
    <url>%2F2020%2F01%2F06%2Fqueue%2F</url>
    <content type="text"><![CDATA[泛型链式队列采用链式队列的原因跟采用链式栈的原因一致：为了 避免使用数组来进行实现时，动态扩容时造成的不必要的空间浪费 。 API 设计1234567891011121314151617181920212223242526272829303132333435#ifndef QUEUE_QUEUE_LINK_H#define QUEUE_QUEUE_LINK_Htemplate &lt;class T&gt;class queue_link &#123;public: queue_link(); // 创建队列 ~queue_link(); // 析构队列（ps：未实现） void enqueue(T t);// 元素入队 void dequeue();// 元素出队 unsigned int size();// 获取当前队列中元素的个数 T front();// 获取队列中首部元素 T back();// 获取队列中尾部元素 bool isEmpty();// 判断队列是否为空private:typedef struct Node&#123; T data; Node* next;&#125; node;private: node m_head;// 头节点 node** m_head_pointer; // 头指针 node** m_tail_pointer; // 尾指针 unsigned int m_size;&#125;; 设计思路 链式队列采用 头删尾插法 原因：1. 若采用 头插尾删 法时，单向链表无法实现取上一个元素。即使保留有尾指针，在每次删除过元素之后，均需要从头节点开始遍历到尾节点，然后重新为尾指针赋值。这样效率太低 原因：2. 采用 头删尾插法，只需要维护一个指向链表第一个元素的头指针，一个指向链表尾部元素的尾指针，和一个头节点即可。这样因为有头节点的存在，可以确定链表的第一个元素位置，每次从头部删除元素后，可以很方便的更新头指针。尾部插入数据，可以很好的规避单向链表无法逆序访问的缺点。 注意：当链表中只没有元素时，添加数据时需要同时更新头指针和尾指针。 当链表中有 1个 元素时，删除元素时，需要同时更新头指针和尾指针 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include "queue_link.h"template&lt;class T&gt;queue_link&lt;T&gt;::queue_link() &#123; m_head_pointer=new node*; m_tail_pointer=new node*; m_head.next = nullptr; *m_head_pointer = &amp;m_head; *m_tail_pointer = &amp;m_head; m_size = 0;&#125;template&lt;class T&gt;queue_link&lt;T&gt;::~queue_link() = default;/** * 从链表的尾部添加数据，实现队列中元素的入队 * 1. 将元素添到 new_node 的数据域,并将 new_node 的指针域指向尾指针的指针域的指向 * 2. 更新尾指针指向元素的指针域，使其指向 new_node * 3. 更新尾指针指向 PS：如果链表中只有一个元素的话，同时需要更新头指针 * @tparam T 队列中的元素的类型 * @param t 添加到队列中的数据 */template&lt;class T&gt;void queue_link&lt;T&gt;::enqueue(T t) &#123; std::cout&lt;&lt;"元素开始入站"&lt;&lt;std::endl; node *new_node = new node; new_node-&gt;data = t; new_node-&gt;next = nullptr; *m_tail_pointer = new_node; // 第一次添加元素 if (nullptr == m_head.next) &#123; // 链表中只有一个元素 *m_head_pointer = new_node; m_head.next = *m_head_pointer; &#125; // 节点入链表 *m_tail_pointer = new_node; ++m_size;&#125;/** * 将元素从链表头部移除，模拟元素的出队 * 1. 更新头指针，将头指针指向待删除元素的下一个元素(如果只有一个元素的话，同时要更新尾指针） * 2. 通过头节点来释放待删除元素（防止内存泄漏） * 3. 更新头节点的指针域指向，使得指针指向当头节点 * @tparam T 队列中的元素类型 */template&lt;class T&gt;void queue_link&lt;T&gt;::dequeue() &#123; if (*m_head_pointer == *m_tail_pointer) &#123; // 链表中只有一个元素 delete *m_head_pointer; (*m_head_pointer)-&gt;next = nullptr; m_head.next = nullptr; *m_head_pointer = *m_tail_pointer = &amp;m_head; --m_size; &#125; else &#123; *m_head_pointer = (*m_head_pointer)-&gt;next; delete m_head.next; m_head.next-&gt;next = nullptr; m_head.next = *m_head_pointer; --m_size; &#125;&#125;template&lt;class T&gt;T queue_link&lt;T&gt;::front() &#123; return (*m_head_pointer)-&gt;data;&#125;template&lt;class T&gt;T queue_link&lt;T&gt;::back() &#123; return (*m_tail_pointer)-&gt;data;&#125;template&lt;class T&gt;unsigned int queue_link&lt;T&gt;::size() &#123; return m_size;&#125;template&lt;class T&gt;bool queue_link&lt;T&gt;::isEmpty() &#123; return 0==m_size;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>队列</tag>
        <tag>泛型队列</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛型动态栈]]></title>
    <url>%2F2020%2F01%2F05%2Fstack%2F</url>
    <content type="text"><![CDATA[数组实现的泛型栈支持各个不同类型的元素来创建栈。模仿 STL 里的栈。 API 设计 bool isEmpty(); 判断栈是否为空 void push(T t); 向栈顶添加元素 void pop(); 弹出栈底元素 T top(); 获取栈底元素 size_t size(); 获取当前栈内元素的个数 设计思路用数组来模拟栈。设数组头为栈底，数组尾为栈顶。插入数据时，从数组尾部进行插入，删除数据时从数组尾部进行删除。 设计原因从数组尾部添加删除元素时，不用额外的移动元素。可使得操作的时间复杂度为 O(1)。操作完成后，更新栈顶位置即可。 代码实现123456789101112131415161718192021222324252627282930313233#ifndef STACK_STACK_H#define STACK_STACK_H#include &lt;cstdio&gt;#include &lt;array&gt;template&lt;typename T&gt;class stack &#123;public: explicit stack(); bool isEmpty(); void push(T t); void pop(); T top(); size_t size();private: void resize();private: T *m_stack; size_t m_size = 0; size_t m_capcities=1;&#125;;#endif //STACK_STACK_H 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include "stack.h"template&lt;typename T&gt;stack&lt;T&gt;::stack() &#123; m_stack = T(m_capcities);&#125;template&lt;typename T&gt;bool stack&lt;T&gt;::isEmpty() &#123; return 0 == m_size;&#125;template&lt;typename T&gt;void stack&lt;T&gt;::push(T t) &#123; if (m_size &gt; (m_capcities / 2)) &#123; resize(); &#125; memcpy(m_stack + m_size, t, sizeof(T));&#125;template&lt;typename T&gt;void stack&lt;T&gt;::pop() &#123; --m_size;&#125;template&lt;typename T&gt;size_t stack&lt;T&gt;::size() &#123; return m_size;&#125;template&lt;typename T&gt;T stack&lt;T&gt;::top() &#123; return *(m_stack + m_size);&#125;/** * 动态扩容栈的容量 * 扩容算法：当前栈内元素 &gt; 1/2 栈的容量时，将栈容量扩容为原来的 2 倍这样可以保证栈使用率不会低于 1/4 * 然后将扩容前栈内的元素，依次拷贝到新栈内。 * @tparam T 栈内存放元素的类型 */template&lt;typename T&gt;void stack&lt;T&gt;::resize() &#123; m_capcities *= 2; size_t length = sizeof(T); T *new_stack = T(m_capcities); for (int i = 0; i &lt; m_size; ++i) &#123; memcpy(new_stack + i * length, m_stack + i * length, length); &#125; m_stack = new_stack;&#125; TODO移除元素时，判断栈容量，申请小容量栈，将原始栈内数据拷贝到小容量栈中。 链表实现的泛型栈API 设计123456789101112131415161718192021222324252627282930313233#ifndef STACK_NODE_STACK_H#define STACK_NODE_STACK_Htemplate&lt;class T&gt;class node_stack &#123;public: node_stack(); // 创建一个新链表栈 int size(); // 链表栈内的元素个数 bool isEmpty();// 链表栈是否为空：空返回 false，非空返回 true void push(T t); // 向链表栈中添加元素 T top(); // 获取链表栈的顶部元素 void pop();// 弹出链表栈的栈顶元素 //TODO void destory(); 释放链表元素private: typedef struct Node &#123; T data; Node *next; &#125; node; int m_size; node m_head;&#125;;// 链表节点#endif //STACK_NODE_STACK_H 设计思路用数组来实现栈，有一个弊端就是会造成一定程度上的空间浪费。所以为了规避掉空间上的浪费，采用线性表中的非连续存储结构：栈来实现对应的栈。实现的栈的特性：添加、删除元素均与现有元素的规模无关。时间复杂度为 O(1) 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include "node_stack.h"template&lt;class T&gt;node_stack&lt;T&gt;::node_stack() &#123; m_size = 0; m_head.next = nullptr;&#125;/** * 链表的头插法，将新节点插入到头节点之后 * new_node 的指针域指向 head 节点的下一个元素 * new_node 的数据域，为待添加的元素 * 将 head 的指针域指向 new_node 完成节点入链 * @tparam T 待插入数据的类型 * @param t 待插入数据 */template&lt;class T&gt;void node_stack&lt;T&gt;::push(T t) &#123; node *new_node=new node; new_node-&gt;data=t; new_node-&gt;next=m_head.next; m_head.next=new_node; ++m_size;&#125;template&lt;class T&gt;int node_stack&lt;T&gt;::size() &#123; return m_size;&#125;template&lt;class T&gt;bool node_stack&lt;T&gt;::isEmpty() &#123; return 0 == m_size;&#125;template&lt;class T&gt;T node_stack&lt;T&gt;::top() &#123; return m_head.next-&gt;data;&#125;template&lt;class T&gt;void node_stack&lt;T&gt;::pop() &#123; m_head.next = m_head.next-&gt;next; --m_size;&#125; 弊端如果频繁的对栈内元素进行删除操作或是销毁栈，此时容易造成内存碎片化。解决思路：使用内存池计数。 题外话最近一直在学前端……难受的一批，好久没更新过了……抽空写一篇水文:-D]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>栈</tag>
        <tag>泛型栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[右值引用的特点]]></title>
    <url>%2F2019%2F10%2F22%2F%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E7%9A%84%E7%89%B9%E7%82%B9%2F</url>
    <content type="text"><![CDATA[右值引用的特点 右值引用的特点分为三部分： 右值引用作用于临时变量 右值引用的值类别 右值引用的值类别的确定 右值引用是移动语义和完美转发的基础，是一个非常重要但又晦涩难懂的概念。若是从其特点对其进行归纳，则可以较好的对其进行理解。 右值引用作用于临时变量 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;struct A&#123; A()&#123; static int struct_count=0; // 构造函数调用次数计数 cout&lt;&lt;"构造函数调用次数: "&lt;&lt;++struct_count&lt;&lt;endl; &#125; A(const A&amp; a) &#123; static int copy_count=0; // 拷贝构造函数调用次数计数 cout&lt;&lt;"拷贝构造函数调用次数: "&lt;&lt;++copy_count &lt;&lt;endl; &#125; ~A() &#123; static int destruct_count=0; // 析构函数调用次数计数 cout&lt;&lt;"析构函数调用次数: "&lt;&lt;++destruct_count&lt;&lt;endl; &#125;&#125;;A getA()&#123; return A(); // C++ 为值语义，此处调用函数调用顺序为，一次构造函数，一次拷贝构造函数，一次析构&#125;int main() &#123; A a = getA(); // 此处调用一次拷贝构造，一次析构 return 0;// 执行结束后 a 执行一次析构&#125; 不进行返回值优化时程序的运行结果在利用 g++ 进行编译时，指定取消返回值优化 -fno-elide-constructors 后，我们可以获取到如下的输入: g++ 版本 7.4.0 Linux 内核版本 4.15.0 构造函数调用次数: 1 25 行 调用 构造函数 构造出一个临时对象 A （纯右值） 拷贝构造函数调用次数: 1 25 行 调用 拷贝构造，将临时对象 A 进行值拷贝（匿名对象，纯右值）然后返回 析构函数调用次数: 1 25 行 调用 析构函数，将临时对象 A 进行析构 拷贝构造函数调用次数: 2 29 行 将 getA 返回的匿名对象，拷贝赋值给 变量 a（纯右值赋值给左值） 析构函数调用次数: 2 29 行 匿名对象在拷贝给变量 a 之后，改行代码执行完成，进行 匿名对象 的析构 析构函数调用次数: 3 30 行 在 30 行执行完毕后，整个程序的生命周期结束，对变量进行释放，调用一次 变量 a 的析构函数 进行返回值优化后，程序的运行结果进行返回值优化后，代码的输出如下: 构造函数调用次数: 1析构函数调用次数: 1 可以很清楚的看到，编译器会将临时变量给进行优化（去除），但是在 C++ 的标准中未规定，要对临时变量进行优化。这是编译器自身的行为，是不可预测的！ 右值引用时，程序的运行结果那么有没有一种方法，可以让我们手动的实现类似编译器的优化效果，来达到代码在不同编译器编译后，行为的一致性呢？ 答案是肯定的，我们可以通过 右值引用 来避免对 临时对象频繁拷贝 造成的开销。 对上述代码的 29 行进行优化： 优化前：A a = getA(); 优化后：A&amp;&amp; a = getA(); 编译时，同样的指定 返回值优化 ，代码的执行结果如下： 构造函数调用次数: 1 25 行 调用 构造函数 构造出一个临时对象 A （纯右值） 拷贝构造函数调用次数: 1 29 行 调用 拷贝构造函数 将构造出的临时对象 A ，拷贝给一个 匿名对象 ，进行返回 析构函数调用次数: 1 29 行 临时对象 A 在完成了，拷贝之后，调用析构函数 析构函数调用次数: 2 30行 在 30 行代码执行完毕之后，程序的生命周期结束，变量进行释放，此时调用 匿名对象 的析构函数 PS：怀疑以上结果的话，可以在对上面代码进行反汇编，然后着重看拷贝函数的调用即可。汇编码，太晦涩了，就不贴上来了。 通过以上结果，可知在进行 右值引用 时，可以延长临时变量的生命周期（对应第 30 行代码），使得临时变量的生命周期与对临时变量进行右值引用的变量的生命周期一致。同时可以避免对临时变量进行的不必要的拷贝开销。 总结： 右值引用有以下特点： 延长临时变量的生命周期 避免对临时变量进行的不必要的拷贝产生的开销 特殊情况万能引用也可以实现，右值引用中的：延长变量的生命周期、避免不必要的拷贝产生的开销 const A&amp; a=getA(); 但是左值引用不能。因为左值只能引用左值！ 右值引用独立于左值和右值右值引用，是独立于左值和右值的，即右值引用的所引用的对象，既可以是右值又可以是左值。 1int&amp;&amp; num = 1; num 为左值因为 num 可以取地址、非临时变量、而且 num 是被字面量所初始化的变量，但是 num 为右值引用。 右值引用的值类型既然右值引用所引用的对象可以是左值、右值，那么右值引用自身是什么类型呢？即 int &amp;&amp; 自身是什么类型呢？ 123456template&lt;typename T&gt;void func(T&amp;&amp; t);func(10);// 右值int i=1;func(i);// 左值 综上可得，右值引用自身的值类型不确定。右值引用自身的值类型可以为: 右值、左值。 右值引用的值类型的确定1234567template&lt;typename T&gt;void func(T&amp;&amp; t); // 未确定template&lt;typename T&gt;class RvalType&#123; RvalType(RvalType&amp;&amp; rvalues); // 右值&#125; T&amp;&amp; 的值类型为未定的引用类型（universal reference），需要由模板自动推断来确定。具体的值类型依赖于其所引用的变量 t 的类型。t 为左值 T&amp;&amp; 为左值、t 为右值 T&amp;&amp; 为右值。 而 RvalType&amp;&amp; 的值类型已经确定（6行指定了引用的类型为右值类型的变量，所有其值类型为右值），不用由模板自动推导来确定。 引用折叠为了处理由右值引用引出的，左值引用引用左值引用、左值引用引用右值引用、右值引用与左值引用、右值引用引用右值引用……的情况，C++ 11 中规定了引用折叠时的规则，以方便确定复杂引用时的表达式的值类型。 引用折叠的规则右值引用叠加到右值引用上，仍然为右值引用。 其他类型的引用叠加到左值引用上，为左值引用。 1234int &amp;&amp;a=10;int &amp;b=a; // 左值引用int &amp;&amp;b =a; // 右值引用int &amp;&amp;c=b; // 左值引用]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>语义</tag>
        <tag>右值引用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++继承]]></title>
    <url>%2F2019%2F10%2F12%2FC-%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[继承 继承是面向对象编程中的一个非常重要的概念，它允许你用一个类 B 来获取另外一个类 A 的属性。A 类称为 基类 B 类称为 子类 。 继承思想很好的体现了程序设计中的 开闭原则 允许我们，在不对某块源码进行修改的情况下，进行新功能的添加和已有功能的完善。实现了高内聚低耦合 。 C++ 中继承的属性 C++ 中继承的属性分为: public 类内和类外均可访问类内属性为 public 的成员变量 继承时，子类继承所有属性为 public 的成员变量 protected 类外不可访问属性为 protected 的成员变量，类内可以访问 继承时，子类继承所有属性为 public、protected 属性的成员变量 private 类外不可访问属性为 private 的成员变量，类内可以访问 继承时，子类不继承属性为 private 的成员变量 总结: 在类外对类内的属性进行访问时，只可以访问属性为 public 的成员变量。 注意: 当类外的某个函数被声明为类的友元的时候，可该友元函数可以不受访问权限的制约，访问类内所有的成员变量。 当发生类的继承的时候，受到访问权限的制约，只能继承属性为 public、protected 的成员变量。 继承的问题 继承在复杂的情况下，会出现不可控的情况。例如菱形继承，菱形继承中会出现基类的变量，在每个继承的子类中各存在一份的情况。造成了，无法共享实现类间共享数据、空间浪费等问题。 菱形继承菱形继承的场景如下: graph TD A[基类]-->|继承| B(子类B) A-->|继承| C(子类C) B-->|继承| D(子类D) C-->|继承| D(子类D) 此时 B 类中存在着一份 A 类的变量，C 类中存在着一份 A 类的变量。两份 A 类的变量，各自独立，互不影响。但是在底层类 D 中，进行调用顶层类 A 中的变量，会出现二义性错误 代码如下： 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;class Animal&#123;public: int eat; int sleep;&#125;;class Sheep : public Animal&#123;public: int horn;&#125;;class Camel : public Animal&#123;public: int hump;&#125;;class SheepCamel :public Sheep, public Camel&#123;public: int fail;&#125;; 在 vs 中查看类的模型如下: 可以很清楚的看到，上面的继承是一个菱形继承，导致了继承成员变量冲突的问题(二义性）。 注意： 虽然可以通过 作用域解析运算符，来指定在菱形继承中的底部类，要使用哪个菱形继承的中间类的变量，但是不推荐使用。通过作用域运算符来指定调用对象的方法，见下面的多继承代码实现。 多继承同时多继承也存在着类似菱形继承的问题：多继承中，A 类继承了 B 类，同时 A 类继承了 C 类 且 B 类和 C 类存在同名的成员变量，或方法。那么在 A 类中对重名的元素进行调用时，会因为二义性导致出错。场景如下： graph TD A[类A]-->|继承|C(类C) B[类B]-->|继承|C 代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Flyable&#123;public: void fly() &#123; cout &lt;&lt; "飞..." &lt;&lt; endl; &#125; void sound() &#123; cout &lt;&lt; "biubiubiu" &lt;&lt; endl; &#125;&#125;;class Run&#123;public: void run() &#123; cout &lt;&lt; "冲冲冲" &lt;&lt; endl; &#125; void sound() &#123; cout &lt;&lt; "biupubiupu" &lt;&lt; endl; &#125;&#125;;class SuperMan :public Flyable, public Run&#123;&#125;;// 多继承void test01()&#123; SuperMan man; man.fly(); man.Flyable::sound(); // 报错，二义性（在继承的对象中，有多个同名的函数) //man.sound(); man.run(); man.Run::sound();&#125; 虚继承 为了解决上述的多继承和菱形继承中的问题，C++ 实现了一种新的继承方式：虚继承。虚继承，解决了在从多个路径继承同一个类时出现的数据冗余，调用时出现的二义性，节省了内存开销。 虚继承原理 在从多个路径继承同一个基类的时候，每个不同的路径在继承时，都声明继承方式为虚继承， 那么在虚继承时，各个子类内部保存的不是基类的数据的拷贝，而是一个 指向基类的指针 。在需要使用基类中的数据时，直接通过指针来进行调用基类中的数据。 流程图如下： graph TD A[基类]-->|虚继承|B(子类B) A[基类]-->|虚继承|C(子类C) B[子类B]-->|继承|D(子类D) C[子类C]-->|继承|D(子类D) 此时在底层类 D 中再去对顶层类 A 中的成员进行调用，就可以避免了二义性，而且中间类 B、C均保存了一份指向顶层类 A 的指针，通过指针，而不是数据拷贝来使用顶层类 A 的数据。 代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687class Aaa&#123;public: Aaa() &#123; cout &lt;&lt; "A 的构造函数" &lt;&lt; endl; m_a = 100; &#125; ~Aaa() &#123; cout &lt;&lt; "A 的析构函数" &lt;&lt; endl; &#125;public: int m_a;&#125;;class Bbb :virtual public Aaa&#123;public: Bbb() &#123; cout &lt;&lt; "B 的构造函数" &lt;&lt; endl; m_b = 100; // 虚继承指向的是同一个 A m_a = 5; &#125; ~Bbb() &#123; cout &lt;&lt; "B 的析构函数" &lt;&lt; endl; &#125;public: int m_b;&#125;;class Ccc :virtual public Aaa&#123;public: int m_c;public: Ccc() &#123; cout &lt;&lt; "C 的构造函数" &lt;&lt; endl; &#125; ~Ccc() &#123; cout &lt;&lt; "C 的析构函数" &lt;&lt; endl; &#125;&#125;;class Ddd : public Bbb, public Ccc&#123;public: int m_d;public: Ddd() &#123; cout &lt;&lt; "D 的构造函数" &lt;&lt; endl; &#125; ~Ddd() &#123; cout &lt;&lt; "D 的析构函数" &lt;&lt; endl; &#125;&#125;;// 菱形继承，会导致在底层的类中// 出现多份顶层的类的成员// 且每份顶层的类的成员各自独立// 去调用时会有二义性void test02()&#123; Ddd d; // 出现二义性调用错误 //d.m_a; // 虚继承之后，则不会出现二义性 d.m_a; cout &lt;&lt; d.Ccc::m_a &lt;&lt; endl;&#125; 总结在继承时，通过虚继承方式，可以很好的规避在从多个路径继承同一个基类时，出现的数据冗余及在通过继承类调用基类中数据出现的二义性。同时，类的继承是很好的实现开闭原则的方式。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>继承</tag>
        <tag>虚继承</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的左值和右值]]></title>
    <url>%2F2019%2F10%2F05%2FC%2B%2B%E4%B8%AD%E7%9A%84%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC%2F</url>
    <content type="text"><![CDATA[基本概念 C++ 中每个表达式均有两种类型： 值类别(values categories) 和 类型(type) 。 作用： 值类别：编译器在对表达式进行创建、复制、移动临时对象时必须遵循的规则。通俗来说，值类别是用于程序运行时编译器进行语法检查。 类型： 编译器在编译阶段用于分配内存的依据、以及确定表达式或变量可以进行的操作。通俗来讲，类型是用于编译器在编译器在编译阶段进行类型检查。 可以较为简单的将 类型 和 值类别 理解为：类型决定了是什么，而值类别绝对了怎么做。 注意: 类型和值类别是独立的两种属性，不存在谁依赖于谁。只是在其行为上看来有依赖关系。 左值和右值均属于值类型。 C++11 中的值类别 C++ 中值类别分为：泛左值、右值、左值、将亡值、纯右值。不同值类型别间的关系，见下图: graph TD A[值类型] --> B[glvalue] B --> lvalue B -->xvalue A --> C[rvalue] C-->xvalue C-->prvalue ## 值类别的定义 以下内容引用自 cppreference 泛左值 (glvalue)（“泛化 (generalized)”的左值）是其求值确定一个对象、位域或函数的个体的表达式； 纯右值 (prvalue)（“纯 (pure)”的右值）是求值符合下列之一的表达式： 计算某个运算符的操作数的值（这种纯右值没有结果对象），或者初始化某个对象或位域 （称这种纯右值有一个结果对象）。所有类和数组的纯右值都有结果对象，即使它被舍弃也是如此。在某些语境中，将发生临时量实质化，以创建作为其结果对象的临时量； 亡值 (xvalue)（“将亡 (expiring)”的值）是代表其资源能够被重新使用的对象或位域的泛左值； 左值 (lvalue)（如此称呼的历史原因是，左值可以出现于赋值表达式的左边）是非亡值的泛左值； 右值 (rvalue)（如此称呼的历史原因是，右值可以出现于赋值表达式的右边）是纯右值或者亡值。 区分值类别的方法 知道什么值类别的作用、不同值类别之间的关系以及什么是值类别后，还需要了解如何区分不同的值类别，才可以进行运用。 如果从定义上进行值类别的区别，会发现无从下手……定义说的是什么鬼东西，这是正常人能明白的么？？ 可以从定义出发，提取出左值和右值的关键特性，进而通过特性来对他们进行区分。 特性区分 看要区分的对象能否取地址即可。 左值具有程序可以访问的地址，即 可以取地址 为左值 右值不具有程序可以访问的地址(但是却具有映射到物理内存的地址）即 不可取地址 ，为右值 定义区分12345678int a = 10; // 左值表达式，求值确定了一个 int 对象 a class B&#123;&#125;; // 内部属性省略B c; // 左值表达式 表达式 C 为一个 B 类的实例化对象, 求值初始化了一个对象c.name = "a"; // 左值c.age = 10; // 左值B d;d("b", 20); // 左值表达式 求值初始化了对象 dfunc(a) + func(b); // 右值 func 为右值求值确定了 + 运算符的操作数，在表达式中，func 作为操作数 总结：从定义上来看，右值表达式，返回的是一个临时变量，其作用域只有使用它的位置（类似匿名表达式)]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>语义</tag>
      </tags>
  </entry>
</search>
